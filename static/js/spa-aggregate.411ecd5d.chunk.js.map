{"version":3,"file":"static/js/spa-aggregate.411ecd5d.chunk.js","mappings":"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","sources":["../node_modules/@newrelic/browser-agent/dist/esm/common/deny-list/deny-list.js","../node_modules/@newrelic/browser-agent/dist/esm/common/harvest/harvest-scheduler.js","../node_modules/@newrelic/browser-agent/dist/esm/common/serialize/bel-serializer.js","../node_modules/@newrelic/browser-agent/dist/esm/common/unload/eol.js","../node_modules/@newrelic/browser-agent/dist/esm/features/spa/aggregate/interaction-node.js","../node_modules/@newrelic/browser-agent/dist/esm/features/spa/aggregate/interaction.js","../node_modules/@newrelic/browser-agent/dist/esm/features/spa/aggregate/serializer.js","../node_modules/@newrelic/browser-agent/dist/esm/features/spa/aggregate/index.js","../node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js"],"sourcesContent":["/** An array of filter objects {hostname, pathname} for identifying XHR events to be excluded from collection.\n * @see {@link https://docs.newrelic.com/docs/browser/new-relic-browser/configuration/filter-ajax-request-events/ Filter AjaxRequest events}\n * @type {Array.<{hostname: string, pathname: string}>}\n */\nvar denyList = [];\n\n/**\n * Evaluates whether an XHR event should be included for collection based on the {@link denyList|AjaxRequest deny list}.\n * @param {Object} params - object with properties of the XHR event\n * @returns {boolean} `true` if request does not match any entries of {@link denyList|deny list}; else `false`\n */\nexport function shouldCollectEvent(params) {\n  if (denyList.length === 0) {\n    return true;\n  }\n\n  // XHR requests with an undefined hostname (e.g., data URLs) should not be collected.\n  if (params.hostname === undefined) {\n    return false;\n  }\n  for (var i = 0; i < denyList.length; i++) {\n    var parsed = denyList[i];\n    if (parsed.hostname === '*') {\n      return false;\n    }\n    if (domainMatchesPattern(parsed.hostname, params.hostname) && comparePath(parsed.pathname, params.pathname)) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * Initializes the {@link denyList|XHR deny list} by extracting hostname and pathname from an array of filter strings.\n * @param {string[]} denyListConfig - array of URL filters to identify XHR requests to be excluded from collection\n */\nexport function setDenyList(denyListConfig) {\n  denyList = [];\n  if (!denyListConfig || !denyListConfig.length) {\n    return;\n  }\n  for (var i = 0; i < denyListConfig.length; i++) {\n    let url = denyListConfig[i];\n    if (!url) continue; // ignore bad values like undefined or empty strings\n\n    if (url.indexOf('http://') === 0) {\n      url = url.substring(7);\n    } else if (url.indexOf('https://') === 0) {\n      url = url.substring(8);\n    }\n    const firstSlash = url.indexOf('/');\n    let host, pathname;\n    if (firstSlash > 0) {\n      host = url.substring(0, firstSlash);\n      pathname = url.substring(firstSlash);\n    } else {\n      host = url;\n      pathname = '';\n    }\n    let [hostname] = host.split(':');\n    denyList.push({\n      hostname,\n      pathname\n    });\n  }\n}\n/**\n * Returns true if the right side of `domain` (end of string) matches `pattern`.\n * @param {string} pattern - a string to be matched against the end of `domain` string\n * @param {string} domain - a domain string with no protocol or path (e.g., app1.example.com)\n * @returns {boolean} `true` if domain matches pattern; else `false`\n */\nfunction domainMatchesPattern(pattern, domain) {\n  if (pattern.length > domain.length) {\n    return false;\n  }\n  return domain.indexOf(pattern) === domain.length - pattern.length;\n}\n\n/**\n * Returns true if a URL path matches a pattern string, disregarding leading slashes.\n * @param {string} pattern - a string to compare with path (e.g., api/v1)\n * @param {string} path - a string representing a URL path (e.g., /api/v1)\n * @returns {boolean} `true` if path and pattern are an exact string match (except for leading slashes); else `false`\n */\nfunction comparePath(pattern, path) {\n  if (pattern.indexOf('/') === 0) {\n    pattern = pattern.substring(1);\n  }\n  if (path.indexOf('/') === 0) {\n    path = path.substring(1);\n  }\n\n  // No path in pattern means match all paths.\n  if (pattern === '') {\n    return true;\n  }\n  return pattern === path;\n}","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport * as submitData from '../util/submit-data';\nimport { SharedContext } from '../context/shared-context';\nimport { Harvest } from './harvest';\nimport { subscribeToEOL } from '../unload/eol';\nimport { SESSION_EVENTS } from '../session/session-entity';\n\n/**\n * Periodically invokes harvest calls and handles retries\n */\nexport class HarvestScheduler extends SharedContext {\n  /**\n     * Create a HarvestScheduler\n     * @param {string} endpoint - The base BAM endpoint name -- ex. 'events'\n     * @param {object} opts - The options used to configure the HarvestScheduler\n     * @param {Function} opts.onFinished - The callback to be fired when a harvest has finished\n     * @param {Function} opts.getPayload - A callback which can be triggered to return a payload for harvesting\n     * @param {number} opts.retryDelay - The number of seconds to wait before retrying after a network failure\n     * @param {boolean} opts.raw - Use a prefabricated payload shape as the harvest payload without the need for formatting\n     * @param {string} opts.customUrl - A custom url that falls outside of the shape of the standard BAM harvester url pattern.  Will use directly instead of concatenating various pieces\n     * @param {*} parent - The parent object, whose state can be passed into SharedContext\n     */\n  constructor(endpoint, opts, parent) {\n    super(parent); // gets any allowed properties from the parent and stores them in `sharedContext`\n    this.endpoint = endpoint;\n    this.opts = opts || {};\n    this.started = false;\n    this.timeoutHandle = null;\n    this.aborted = false; // this controls the per-interval and final harvests for the scheduler (currently per feature specific!)\n\n    this.harvest = new Harvest(this.sharedContext);\n\n    // unload if EOL mechanism fires\n    subscribeToEOL(this.unload.bind(this));\n\n    /* Flush all buffered data if session resets and give up retries. This should be synchronous to ensure that the correct `session` value is sent.\n      Since session-reset generates a new session ID and the ID is grabbed at send-time, any delays or retries would cause the payload to be sent under\n      the wrong session ID. */\n    this.sharedContext?.ee.on(SESSION_EVENTS.RESET, () => this.runHarvest({\n      forceNoRetry: true\n    }));\n  }\n\n  /**\n   * This function is only meant for the last outgoing harvest cycle of a page. It trickles down to using sendBeacon, which should not be used\n   * to send payloads while the page is still active, due to limitations on how much data can be buffered in the API at any one time.\n   */\n  unload() {\n    if (this.aborted) return;\n    // If opts.onUnload is defined, these are special actions to execute before attempting to send the final payload.\n    if (this.opts.onUnload) this.opts.onUnload();\n    this.runHarvest({\n      unload: true\n    });\n  }\n  startTimer(interval, initialDelay) {\n    this.interval = interval;\n    this.started = true;\n    this.scheduleHarvest(initialDelay != null ? initialDelay : this.interval);\n  }\n  stopTimer() {\n    let permanently = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    this.aborted = permanently; // stopping permanently is same as aborting, but this function also cleans up the setTimeout loop\n    this.started = false;\n    if (this.timeoutHandle) {\n      clearTimeout(this.timeoutHandle);\n    }\n  }\n  scheduleHarvest(delay, opts) {\n    if (this.timeoutHandle) return;\n    if (delay == null) {\n      delay = this.interval;\n    }\n    this.timeoutHandle = setTimeout(() => {\n      this.timeoutHandle = null;\n      this.runHarvest(opts);\n    }, delay * 1000);\n  }\n  runHarvest(opts) {\n    if (this.aborted) return;\n\n    /**\n     * This is executed immediately after harvest sends the data via XHR, or if there's nothing to send. Note that this excludes on unloading / sendBeacon.\n     * @param {Object} result\n     */\n    const cbRanAfterSend = result => {\n      if (opts?.forceNoRetry) result.retry = false; // discard unsent data rather than re-queuing for next harvest attempt\n      this.onHarvestFinished(opts, result);\n    };\n    let harvests = [];\n    let submitMethod;\n    let payload;\n    if (this.opts.getPayload) {\n      // Ajax & PVT & SR features provide a callback function to get data for harvesting\n      submitMethod = submitData.getSubmitMethod({\n        isFinalHarvest: opts?.unload\n      });\n      if (!submitMethod) return false;\n      const retry = !opts?.unload && submitMethod === submitData.xhr;\n      payload = this.opts.getPayload({\n        retry\n      });\n      if (!payload) {\n        if (this.started) {\n          this.scheduleHarvest();\n        }\n        return;\n      }\n      payload = Object.prototype.toString.call(payload) === '[object Array]' ? payload : [payload];\n      harvests.push(...payload);\n    }\n\n    /** sendX is used for features that do not supply a preformatted payload via \"getPayload\" */\n    let send = args => this.harvest.sendX(args);\n    if (harvests.length) {\n      /** _send is the underlying method for sending in the harvest, if sending raw we can bypass the other helpers completely which format the payloads */\n      if (this.opts.raw) send = args => this.harvest._send(args);\n      /** send is used to formated the payloads from \"getPayload\" and obfuscate before sending */else send = args => this.harvest.send(args);\n    } else {\n      // force it to run at least once in sendX mode\n      harvests.push(undefined);\n    }\n    harvests.forEach(payload => {\n      send({\n        endpoint: this.endpoint,\n        payload,\n        opts,\n        submitMethod,\n        cbFinished: cbRanAfterSend,\n        customUrl: this.opts.customUrl,\n        raw: this.opts.raw\n      });\n    });\n    if (this.started) {\n      this.scheduleHarvest();\n    }\n  }\n  onHarvestFinished(opts, result) {\n    if (this.opts.onFinished) {\n      this.opts.onFinished(result);\n    }\n    if (result.sent && result.retry) {\n      const delay = result.delay || this.opts.retryDelay;\n      // reschedule next harvest if should be delayed longer\n      if (this.started && delay) {\n        clearTimeout(this.timeoutHandle);\n        this.timeoutHandle = null;\n        this.scheduleHarvest(delay, opts);\n      } else if (!this.started && delay) {\n        // if not running on a timer, schedule a single retry\n        this.scheduleHarvest(delay, opts);\n      }\n    }\n  }\n}","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { mapOwn } from '../util/map-own';\nimport { stringify } from '../util/stringify';\nimport { Obfuscator } from '../util/obfuscate';\nvar hasOwnProp = Object.prototype.hasOwnProperty;\nvar MAX_ATTRIBUTES = 64;\nexport function nullable(val, fn, comma) {\n  return val || val === 0 || val === '' ? fn(val) + (comma ? ',' : '') : '!';\n}\nexport function numeric(n, noDefault) {\n  if (noDefault) {\n    return Math.floor(n).toString(36);\n  }\n  return n === undefined || n === 0 ? '' : Math.floor(n).toString(36);\n}\nexport function getAddStringContext(agentIdentifier) {\n  // eslint-disable-next-line\n  var stringTable = Object.hasOwnProperty('create') ? Object.create(null) : {};\n  var stringTableIdx = 0;\n  return addString;\n  function addString(str) {\n    if (typeof str === 'undefined' || str === '') return '';\n    var obfuscator = new Obfuscator({\n      agentIdentifier\n    });\n    str = String(str);\n    if (obfuscator.shouldObfuscate()) str = obfuscator.obfuscateString(str);\n    if (hasOwnProp.call(stringTable, str)) {\n      return numeric(stringTable[str], true);\n    } else {\n      stringTable[str] = stringTableIdx++;\n      return quoteString(str);\n    }\n  }\n}\nexport function addCustomAttributes(attrs, addString) {\n  var attrParts = [];\n  mapOwn(attrs, function (key, val) {\n    if (attrParts.length >= MAX_ATTRIBUTES) return;\n    var type = 5;\n    var serializedValue;\n    // add key to string table first\n    key = addString(key);\n    switch (typeof val) {\n      case 'object':\n        if (val) {\n          // serialize objects to strings\n          serializedValue = addString(stringify(val));\n        } else {\n          // null attribute type\n          type = 9;\n        }\n        break;\n      case 'number':\n        type = 6;\n        // make sure numbers contain a `.` so they are parsed as doubles\n        serializedValue = val % 1 ? val : val + '.';\n        break;\n      case 'boolean':\n        type = val ? 7 : 8;\n        break;\n      case 'undefined':\n        // we treat undefined as a null attribute (since dirac does not have a concept of undefined)\n        type = 9;\n        break;\n      default:\n        serializedValue = addString(val);\n    }\n    attrParts.push([type, key + (serializedValue ? ',' + serializedValue : '')]);\n  });\n  return attrParts;\n}\nvar escapable = /([,\\\\;])/g;\nfunction quoteString(str) {\n  return \"'\" + str.replace(escapable, '\\\\$1');\n}","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { windowAddEventListener } from '../event-listener/event-listener-opts';\nimport { globalScope, isWorkerScope, isBrowserScope } from '../constants/runtime';\nimport { subscribeToVisibilityChange } from '../window/page-visibility';\nif (isWorkerScope) {\n  globalScope.cleanupTasks = []; // create new list on WorkerGlobalScope to track funcs to run before exiting thread\n\n  const origClose = globalScope.close;\n  globalScope.close = () => {\n    // on worker's EoL signal, execute all \"listeners\", e.g. final harvests\n    for (let task of globalScope.cleanupTasks) {\n      task();\n    }\n    origClose();\n  };\n}\n\n/**\n * Subscribes a provided callback to the time/event when the agent should treat it as end-of-life.\n * This is used, for example, to submit a final harvest and send all remaining data on best-effort.\n * @param {function} cb - func to run before or during the last reliable event or time of an env's life span\n */\nexport function subscribeToEOL(cb) {\n  if (isBrowserScope) {\n    subscribeToVisibilityChange(cb, true); // when user switches tab or hides window, esp. mobile scenario\n    windowAddEventListener('pagehide', cb); // when user navigates away, and because safari iOS v14.4- doesn't fully support vis change\n    // --this ought to be removed once support for version below 14.5 phases out\n  } else if (isWorkerScope) {\n    globalScope.cleanupTasks.push(cb); // close() should run these tasks before quitting thread\n  }\n  // By default (for other env), this fn has no effect.\n}","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar MAX_NODES = 128;\nvar lastId = 0;\nexport function InteractionNode(interaction, parent, type, timestamp) {\n  Object.defineProperty(this, 'interaction', {\n    value: interaction,\n    writable: true // enumerable: false -- by default, which hides this prop from obj (iterations)\n  });\n\n  this.parent = parent;\n  this.id = ++lastId;\n  this.type = type;\n  this.children = [];\n  this.end = null;\n  this.jsEnd = this.start = timestamp;\n  this.jsTime = 0;\n  this.attrs = {};\n  this.cancelled = false;\n}\nvar InteractionNodePrototype = InteractionNode.prototype;\n\n/**\n * @param {string} type\n * @param {number} timestamp\n * @param {string} name\n * @param {bool} dontWait - When true, the interaction will not immediately start waiting\n *                          for this node to complete. This is used when the creation of\n *                          the node and its start happen at different times (e.g. XHR).\n */\nInteractionNodePrototype.child = function child(type, timestamp, name, dontWait) {\n  var interaction = this.interaction;\n  if (interaction.end || interaction.nodes >= MAX_NODES) return null;\n  interaction.onNodeAdded(this);\n  var node = new InteractionNode(interaction, this, type, timestamp);\n  node.attrs.name = name;\n  interaction.nodes++;\n  if (!dontWait) {\n    interaction.remaining++;\n  }\n  return node;\n};\nInteractionNodePrototype.callback = function addCallbackTime(exclusiveTime, end) {\n  var node = this;\n  node.jsTime += exclusiveTime;\n  if (end > node.jsEnd) {\n    node.jsEnd = end;\n    node.interaction.lastCb = end;\n  }\n};\nInteractionNodePrototype.cancel = function cancel() {\n  this.cancelled = true;\n  var interaction = this.interaction;\n  interaction.remaining--;\n};\nInteractionNodePrototype.finish = function finish(timestamp) {\n  var node = this;\n  if (node.end) return;\n  node.end = timestamp;\n\n  // Find the next parent node that is not cancelled\n  let parent = node.parent;\n  while (parent?.cancelled) parent = parent.parent;\n\n  // Assign the node to the non-cancelled parent node\n  if (parent) parent.children.push(node);\n  node.parent = null;\n\n  // Update the interaction remaining counter\n  var interaction = this.interaction;\n  interaction.remaining--;\n  interaction.lastFinish = timestamp;\n  // check if interaction has finished, (this is needed for older browsers for unknown reasons)\n  interaction.checkFinish();\n};","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { getInfo, getRuntime, originals } from '../../../common/config/config';\nimport { mapOwn } from '../../../common/util/map-own';\nimport { ee } from '../../../common/event-emitter/contextual-ee';\nimport { InteractionNode } from './interaction-node';\nvar originalSetTimeout = originals.ST;\nvar originalClearTimeout = originals.CT;\nvar lastId = {};\nexport function Interaction(eventName, timestamp, url, routeName, onFinished, agentIdentifier) {\n  this.agentIdentifier = agentIdentifier;\n  this.ee = ee.get(agentIdentifier);\n  lastId[agentIdentifier] = 0;\n  this.id = ++lastId[agentIdentifier];\n  this.eventName = eventName;\n  this.nodes = 0;\n  this.remaining = 0;\n  this.finishTimer = null;\n  this.checkingFinish = false;\n  this.lastCb = this.lastFinish = timestamp;\n  this.handlers = [];\n  this.onFinished = onFinished;\n  this.done = false;\n  var root = this.root = new InteractionNode(this, null, 'interaction', timestamp);\n  var attrs = root.attrs;\n  attrs.trigger = eventName;\n  attrs.initialPageURL = getRuntime(agentIdentifier).origin;\n  attrs.oldRoute = routeName;\n  attrs.newURL = attrs.oldURL = url;\n  attrs.custom = {};\n  attrs.store = {};\n}\nvar InteractionPrototype = Interaction.prototype;\nInteractionPrototype.checkFinish = function checkFinish() {\n  var interaction = this;\n  if (interaction.remaining > 0) {\n    interaction._resetFinishCheck();\n    return;\n  }\n  if (interaction.checkingFinish) {\n    return;\n  }\n  if (interaction.root.end !== null) return;\n  interaction._resetFinishCheck();\n  interaction.checkingFinish = true;\n  interaction.finishTimer = originalSetTimeout(() => {\n    interaction.checkingFinish = false;\n    interaction.finishTimer = originalSetTimeout(() => {\n      interaction.finishTimer = null;\n      if (interaction.remaining <= 0) interaction.finish();\n    }, 1);\n  }, 0);\n};\nInteractionPrototype.setNewURL = function setNewURL(url) {\n  this.root.attrs.newURL = url;\n};\nInteractionPrototype.setNewRoute = function setNewRoute(route) {\n  this.root.attrs.newRoute = route;\n};\nInteractionPrototype.onNodeAdded = function onNodeAdded() {\n  this._resetFinishCheck();\n};\nInteractionPrototype._resetFinishCheck = function _resetFinishCheck() {\n  if (this.finishTimer) {\n    originalClearTimeout(this.finishTimer);\n    this.finishTimer = null;\n    this.checkingFinish = false;\n  }\n};\n\n// serialize report and remove nodes from map\nInteractionPrototype.finish = function finishInteraction() {\n  var interaction = this;\n  var root = interaction.root;\n  if (root.end !== null) return;\n  var endTimestamp = Math.max(interaction.lastCb, interaction.lastFinish);\n  var attrs = root.attrs;\n  var customAttrs = attrs.custom;\n  if (this.onFinished) {\n    this.onFinished(this);\n  }\n  mapOwn(getInfo(interaction.agentIdentifier).jsAttributes, function (attr, value) {\n    if (!(attr in customAttrs)) customAttrs[attr] = value;\n  });\n  root.end = endTimestamp;\n  interaction.ee.emit('interaction', [this]);\n};","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { cleanURL } from '../../../common/url/clean-url';\nimport { mapOwn } from '../../../common/util/map-own';\nimport { nullable, numeric, getAddStringContext, addCustomAttributes } from '../../../common/serialize/bel-serializer';\nimport { SharedContext } from '../../../common/context/shared-context';\nimport { getInfo } from '../../../common/config/config';\nexport class Serializer extends SharedContext {\n  constructor(parent) {\n    super(parent);\n\n    /**\n     * This variable is used to calculate an interactions ending offset when the\n     * harvest includes multiple interactions. This variable is set by the first\n     * interaction processed and used by subsequent interactions in the same harvest.\n     * See https://issues.newrelic.com/browse/NEWRELIC-5498\n     * @type {number|undefined}\n     */\n    this.firstTimestamp = undefined;\n  }\n  serializeMultiple(interactions, offset, navTiming) {\n    const info = getInfo(this.sharedContext.agentIdentifier);\n    var addString = getAddStringContext(this.sharedContext.agentIdentifier);\n    var serialized = 'bel.7';\n    interactions.forEach(interaction => {\n      serialized += ';' + this.serializeInteraction(interaction.root, offset, navTiming, interaction.routeChange, addString, info);\n    });\n    this.firstTimestamp = undefined;\n    return serialized;\n  }\n  serializeSingle(root, offset, navTiming, isRouteChange) {\n    const info = getInfo(this.sharedContext.agentIdentifier);\n    var addString = getAddStringContext(this.sharedContext.agentIdentifier);\n    var serialized = 'bel.7;' + this.serializeInteraction(root, offset, navTiming, isRouteChange, addString, info);\n    this.firstTimestamp = undefined;\n    return serialized;\n  }\n  serializeInteraction(root, offset, navTiming, isRouteChange, addString, info) {\n    offset = offset || 0;\n    var isInitialPage = root.attrs.trigger === 'initialPageLoad';\n    var typeIdsByName = {\n      interaction: 1,\n      ajax: 2,\n      customTracer: 4\n    };\n\n    // Include the hash fragment with all SPA data\n    var includeHashFragment = true;\n    const addNode = (node, nodeList) => {\n      if (node.type === 'customEnd') return nodeList.push([3, numeric(node.end - this.firstTimestamp)]);\n      var typeName = node.type;\n      var typeId = typeIdsByName[typeName];\n      var startTimestamp = node.start;\n      var childCount = node.children.length;\n      var attrCount = 0;\n      var apmAttributes = info.atts;\n      var hasNavTiming = isInitialPage && navTiming.length && typeId === 1;\n      var children = [];\n      var attrs = node.attrs;\n      var metrics = attrs.metrics;\n      var params = attrs.params;\n      var queueTime = info.queueTime;\n      var appTime = info.applicationTime;\n      if (typeof this.firstTimestamp === 'undefined') {\n        startTimestamp += offset;\n        this.firstTimestamp = startTimestamp;\n      } else {\n        startTimestamp -= this.firstTimestamp;\n      }\n      var fields = [numeric(startTimestamp), numeric(node.end - node.start), numeric(node.jsEnd - node.end), numeric(node.jsTime)];\n      switch (typeId) {\n        case 1:\n          fields[2] = numeric(node.jsEnd - this.firstTimestamp);\n          fields.push(addString(attrs.trigger), addString(cleanURL(attrs.initialPageURL, includeHashFragment)), addString(cleanURL(attrs.oldURL, includeHashFragment)), addString(cleanURL(attrs.newURL, includeHashFragment)), addString(attrs.customName), isInitialPage ? '' : isRouteChange ? 1 : 2, nullable(isInitialPage && queueTime, numeric, true) + nullable(isInitialPage && appTime, numeric, true) + nullable(attrs.oldRoute, addString, true) + nullable(attrs.newRoute, addString, true) + addString(attrs.id), addString(node.id), nullable(attrs.firstPaint, numeric, true) + nullable(attrs.firstContentfulPaint, numeric, false));\n          var attrParts = addCustomAttributes(attrs.custom, addString);\n          children = children.concat(attrParts);\n          attrCount = attrParts.length;\n          if (apmAttributes) {\n            childCount++;\n            children.push('a,' + addString(apmAttributes));\n          }\n          break;\n        case 2:\n          fields.push(addString(params.method), numeric(params.status), addString(params.host), addString(params.pathname), numeric(metrics.txSize), numeric(metrics.rxSize), attrs.isFetch ? 1 : attrs.isJSONP ? 2 : '', addString(node.id), nullable(node.dt && node.dt.spanId, addString, true) + nullable(node.dt && node.dt.traceId, addString, true) + nullable(node.dt && node.dt.timestamp, numeric, false));\n\n          // add params.gql here\n          if (Object.keys(params?.gql || {}).length) {\n            var ajaxAttrParts = addCustomAttributes(params.gql, addString);\n            children = children.concat(ajaxAttrParts);\n            attrCount = ajaxAttrParts.length;\n          }\n          break;\n        case 4:\n          var tracedTime = attrs.tracedTime;\n          fields.push(addString(attrs.name), nullable(tracedTime, numeric, true) + addString(node.id));\n          break;\n      }\n      for (var i = 0; i < node.children.length; i++) {\n        addNode(node.children[i], children);\n      }\n      fields.unshift(numeric(typeId), numeric(childCount += attrCount));\n      nodeList.push(fields);\n      if (childCount) {\n        nodeList.push(children.join(';'));\n      }\n      if (hasNavTiming) {\n        // this build up the navTiming node\n        // it for each navTiming value (pre aggregated in nav-timing.js):\n        // we initialize the seperator to ',' (seperates the nodeType id from the first value)\n        // we initialize the navTiming node to 'b' (the nodeType id)\n        // if the value is present:\n        //   we add the seperator followed by the value\n        // otherwise\n        //   we add null seperator ('!') to the navTimingNode\n        //   we set the seperator to an empty string since we already wrote it above\n        //   the reason for writing the null seperator instead of setting the seperator\n        //   is to ensure we still write it if the null is the last navTiming value.\n\n        var seperator = ',';\n        var navTimingNode = 'b';\n        var prev = 0;\n\n        // get all navTiming values except navigationStart\n        // (since its the same as interaction.start)\n        // and limit to just the first 20 values we know about\n        mapOwn(navTiming.slice(1, 21), function (i, v) {\n          if (v !== undefined) {\n            navTimingNode += seperator + numeric(v - prev);\n            seperator = ',';\n            prev = v;\n          } else {\n            navTimingNode += seperator + '!';\n            seperator = '';\n          }\n        });\n        nodeList.push(navTimingNode);\n      } else if (typeId === 1) {\n        nodeList.push('');\n      }\n      return nodeList;\n    };\n    return addNode(root, []).join(';');\n  }\n}","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n/* eslint no-undef: \"error\" */\nimport { registerHandler as register } from '../../../common/event-emitter/register-handler';\nimport { parseUrl } from '../../../common/url/parse-url';\nimport { shouldCollectEvent } from '../../../common/deny-list/deny-list';\nimport { mapOwn } from '../../../common/util/map-own';\nimport { navTimingValues as navTiming } from '../../../common/timing/nav-timing';\nimport { generateUuid } from '../../../common/ids/unique-id';\nimport { Interaction } from './interaction';\nimport { getConfigurationValue, getRuntime } from '../../../common/config/config';\nimport { eventListenerOpts } from '../../../common/event-listener/event-listener-opts';\nimport { HarvestScheduler } from '../../../common/harvest/harvest-scheduler';\nimport { Serializer } from './serializer';\nimport { ee } from '../../../common/event-emitter/contextual-ee';\nimport * as CONSTANTS from '../constants';\nimport { FEATURE_NAMES } from '../../../loaders/features/features';\nimport { AggregateBase } from '../../utils/aggregate-base';\nimport { firstContentfulPaint } from '../../../common/vitals/first-contentful-paint';\nimport { firstPaint } from '../../../common/vitals/first-paint';\nimport { bundleId } from '../../../common/ids/bundle-id';\nconst {\n  FEATURE_NAME,\n  INTERACTION_EVENTS,\n  MAX_TIMER_BUDGET,\n  FN_START,\n  FN_END,\n  CB_START,\n  INTERACTION_API,\n  REMAINING,\n  INTERACTION,\n  SPA_NODE,\n  JSONP_NODE,\n  FETCH_START,\n  FETCH_DONE,\n  FETCH_BODY,\n  JSONP_END,\n  originalSetTimeout\n} = CONSTANTS;\nexport class Aggregate extends AggregateBase {\n  static featureName = FEATURE_NAME;\n  constructor(agentIdentifier, aggregator) {\n    super(agentIdentifier, aggregator, FEATURE_NAME);\n    this.state = {\n      initialPageURL: getRuntime(agentIdentifier).origin,\n      lastSeenUrl: getRuntime(agentIdentifier).origin,\n      lastSeenRouteName: null,\n      timerMap: {},\n      timerBudget: MAX_TIMER_BUDGET,\n      currentNode: null,\n      prevNode: null,\n      nodeOnLastHashUpdate: null,\n      initialPageLoad: null,\n      pageLoaded: false,\n      childTime: 0,\n      depth: 0,\n      harvestTimeSeconds: getConfigurationValue(agentIdentifier, 'spa.harvestTimeSeconds') || 10,\n      interactionsToHarvest: [],\n      interactionsSent: [],\n      // The below feature flag is used to disable the SPA ajax fix for specific customers, see https://new-relic.atlassian.net/browse/NR-172169\n      disableSpaFix: (getConfigurationValue(agentIdentifier, 'feature_flags') || []).indexOf('disable-spa-fix') > -1\n    };\n    this.serializer = new Serializer(this);\n    const {\n      state,\n      serializer\n    } = this;\n    let {\n      blocked\n    } = this;\n    const baseEE = ee.get(agentIdentifier); // <-- parent baseEE\n    const mutationEE = baseEE.get('mutation');\n    const promiseEE = baseEE.get('promise');\n    const historyEE = baseEE.get('history');\n    const eventsEE = baseEE.get('events'); // ajax --> ee(123).emit() ee()\n    const timerEE = baseEE.get('timer');\n    const fetchEE = baseEE.get('fetch');\n    const jsonpEE = baseEE.get('jsonp');\n    const xhrEE = baseEE.get('xhr');\n    const tracerEE = baseEE.get('tracer');\n    const scheduler = new HarvestScheduler('events', {\n      onFinished: onHarvestFinished,\n      retryDelay: state.harvestTimeSeconds\n    }, {\n      agentIdentifier,\n      ee: baseEE\n    });\n    scheduler.harvest.on('events', onHarvestStarted);\n\n    // childTime is used when calculating exclusive time for a cb duration.\n    //\n    // Exclusive time will be different than the total time for either callbacks\n    // which synchronously invoke a customTracer callback or, trigger a synchronous\n    // event (eg. onreadystate=1 or popstate).\n    //\n    // At fn-end, childTime will contain the total time of all timed callbacks and\n    // event handlers which executed as a child of the current callback. At the\n    // begining of every callback, childTime is saved to the event context (which at\n    // that time contains the sum of its preceeding siblings) and is reset to 0. The\n    // callback is then executed, and its children may increase childTime.  At the\n    // end of the callback, it reports its exclusive time as its\n    // execution time - exlcuded. childTime is then reset to its previous\n    // value, and the totalTime of the callback that just finished executing is\n    // added to the childTime time.\n    //                                    | clock | childTime | ctx.ct | totalTime | exclusive |\n    // click fn-start                     |   0   |    0     |    0   |           |           |\n    //  | click begining:                 |   5   |    0     |    0   |           |           |\n    //  |   | custom-1 fn-start           |   10  |    0     |    0   |           |           |\n    //  |   |   |  custom-1 begining      |   15  |    0     |    0   |           |           |\n    //  |   |   |    |  custom-2 fn-start |   20  |    0     |    0   |           |           |\n    //  |   |   |    |  | custom-2        |   25  |    0     |    0   |           |           |\n    //  |   |   |    |  custom-2 fn-end   |   30  |    10    |    0   |     10    |     10    |\n    //  |   |   |  custom-1 middle        |   35  |    10    |    0   |           |           |\n    //  |   |   |    |  custom-3 fn-start |   40  |    0     |    10  |           |           |\n    //  |   |   |    |  | custom-3        |   45  |    0     |    10  |           |           |\n    //  |   |   |    |  custom-3 fn-end   |   50  |    20    |    0   |     10    |     10    |\n    //  |   |   |  custom-1 ending        |   55  |    20    |    0   |           |           |\n    //  |     custom-1 fn-end             |   60  |    50    |    0   |     50    |     30    |\n    //  | click ending:                   |   65  |    50    |        |           |           |\n    // click fn-end                       |   70  |    0     |    0   |     70    |     20    |\n\n    // if rum response determines that customer lacks entitlements for spa endpoint, block it\n    register('block-spa', () => {\n      blocked = true;\n      scheduler.stopTimer(true);\n    }, this.featureName, baseEE);\n    if (!isEnabled()) return;\n    state.initialPageLoad = new Interaction('initialPageLoad', 0, state.lastSeenUrl, state.lastSeenRouteName, onInteractionFinished, agentIdentifier);\n    state.initialPageLoad.save = true;\n    state.prevInteraction = state.initialPageLoad;\n    state.currentNode = state.initialPageLoad.root; // hint\n    // ensure that checkFinish calls are safe during initialPageLoad\n    state.initialPageLoad[REMAINING]++;\n    register(FN_START, callbackStart, this.featureName, baseEE);\n    register(CB_START, callbackStart, this.featureName, promiseEE);\n\n    // register plugins\n    var pluginApi = {\n      getCurrentNode,\n      setCurrentNode\n    };\n    register('spa-register', function (init) {\n      if (typeof init === 'function') {\n        init(pluginApi);\n      }\n    }, FEATURE_NAMES.spa, baseEE);\n    function callbackStart() {\n      state.depth++;\n      this.prevNode = state.currentNode;\n      this.ct = state.childTime;\n      state.childTime = 0;\n      state.timerBudget = MAX_TIMER_BUDGET;\n    }\n    register(FN_END, callbackEnd, this.featureName, baseEE);\n    register('cb-end', callbackEnd, this.featureName, promiseEE);\n    function callbackEnd() {\n      state.depth--;\n      var totalTime = this.jsTime || 0;\n      var exclusiveTime = totalTime - state.childTime;\n      state.childTime = this.ct + totalTime;\n      if (state.currentNode) {\n        // transfer accumulated callback time to the active interaction node\n        // run even if jsTime is 0 to update jsEnd\n        state.currentNode.callback(exclusiveTime, this[FN_END]);\n        if (this.isTraced) {\n          state.currentNode.attrs.tracedTime = exclusiveTime;\n        }\n      }\n      this.jsTime = state.currentNode ? 0 : exclusiveTime;\n      setCurrentNode(this.prevNode);\n      this.prevNode = null;\n      state.timerBudget = MAX_TIMER_BUDGET;\n    }\n    register(FN_START, function (args, eventSource) {\n      var ev = args[0];\n      var evName = ev.type;\n      var eventNode = ev[\"__nrNode:\".concat(bundleId)];\n      if (!state.pageLoaded && evName === 'load' && eventSource === window) {\n        state.pageLoaded = true;\n        // set to null so prevNode is set correctly\n        this.prevNode = state.currentNode = null;\n        if (state.initialPageLoad) {\n          eventNode = state.initialPageLoad.root;\n\n          // Even if initialPageLoad has remaining callbacks, force the initialPageLoad\n          // interaction to complete when the page load event occurs.\n          state.initialPageLoad[REMAINING] = 0;\n          originalSetTimeout(function () {\n            INTERACTION_EVENTS.push('popstate');\n          });\n        }\n      }\n      if (eventNode) {\n        // If we've already seen a previous handler for this specific event object,\n        // just restore that. We want multiple handlers for the same event to share\n        // a node.\n        setCurrentNode(eventNode);\n      } else if (evName === 'hashchange') {\n        setCurrentNode(state.nodeOnLastHashUpdate);\n        state.nodeOnLastHashUpdate = null;\n      } else if (eventSource instanceof XMLHttpRequest) {\n        // If this event was emitted by an XHR, restore the node ID associated with\n        // that XHR.\n        setCurrentNode(baseEE.context(eventSource).spaNode);\n      } else if (!state.currentNode && INTERACTION_EVENTS.indexOf(evName) !== -1) {\n        // Otherwise, if no interaction is currently active, create a new node ID,\n        // and let the aggregator know that we entered a new event handler callback\n        // so that it has a chance to possibly start an interaction.\n        var ixn = new Interaction(evName, this[FN_START], state.lastSeenUrl, state.lastSeenRouteName, onInteractionFinished, agentIdentifier);\n\n        // Store the interaction as prevInteraction in case it is prematurely discarded\n        state.prevInteraction = ixn;\n        setCurrentNode(ixn.root);\n        if (evName === 'click') {\n          var value = getActionText(ev.target);\n          if (value) {\n            state.currentNode.attrs.custom.actionText = value;\n          }\n        }\n      }\n      ev[\"__nrNode:\".concat(bundleId)] = state.currentNode;\n    }, this.featureName, eventsEE);\n\n    /**\n     * *** TIMERS ***\n     * setTimeout call needs to keep the interaction active in case a node is started\n     * in its callback.\n     */\n\n    // The context supplied to this callback will be shared with the fn-start/fn-end\n    // callbacks that fire around the callback passed to setTimeout originally.\n    register('setTimeout-end', function saveId(args, obj, timerId) {\n      if (!state.currentNode || state.timerBudget - this.timerDuration < 0) return;\n      if (args && !(args[0] instanceof Function)) return;\n      state.currentNode[INTERACTION][REMAINING]++;\n      this.timerId = timerId;\n      state.timerMap[timerId] = state.currentNode;\n      this.timerBudget = state.timerBudget - 50;\n    }, this.featureName, timerEE);\n    register('clearTimeout-start', function clear(args) {\n      var timerId = args[0];\n      var node = state.timerMap[timerId];\n      if (node) {\n        var interaction = node[INTERACTION];\n        interaction[REMAINING]--;\n        interaction.checkFinish();\n        delete state.timerMap[timerId];\n      }\n    }, this.featureName, timerEE);\n    register(FN_START, function () {\n      state.timerBudget = this.timerBudget || MAX_TIMER_BUDGET;\n      var id = this.timerId;\n      var node = state.timerMap[id];\n      setCurrentNode(node);\n      delete state.timerMap[id];\n      if (node) node[INTERACTION][REMAINING]--;\n    }, this.featureName, timerEE);\n\n    /**\n     * *** XHR ***\n     * - `new-xhr` event is fired when new instance of XHR is created. Here we create\n     *    a new node and store it on the XHR object.\n     * -  When the send method is called (`send-xhr-start` event), we tell the interaction\n     *    to wait for this XHR to complete.\n     * -  When any direct event handlers are invoked (`fn-start` on the `xhr` emitter),\n     *    we restore the node in case other child nodes are started here.\n     * -  Callbacks attached using `addEventListener` are handled using `fn-start` on the\n     *    `events` emitter.\n     * -  When `xhr-resolved` is emitted, we end the node. The node.finish() call also\n     *    instructs the interaction to stop waiting for this node.\n     */\n\n    // context is shared with new-xhr event, and is stored on the xhr iteself.\n    register(FN_START, function () {\n      setCurrentNode(this[SPA_NODE]);\n    }, this.featureName, xhrEE);\n\n    // context is stored on the xhr and is shared with all callbacks associated\n    // with the new xhr\n    register('new-xhr', function () {\n      if (!state.disableSpaFix && !state.currentNode && state.prevInteraction && !state.prevInteraction.ignored) {\n        /*\n         * The previous interaction was discarded before a route change. Restore the interaction\n         * in case this XHR is associated with a route change.\n         */\n        const interaction = state.prevInteraction;\n        state.currentNode = interaction.root;\n        interaction.root.end = null;\n      }\n      if (state.currentNode) {\n        this[SPA_NODE] = state.currentNode.child('ajax', null, null, true);\n      }\n    }, this.featureName, xhrEE);\n    register('send-xhr-start', function () {\n      var node = this[SPA_NODE];\n      if (node && !this.sent) {\n        this.sent = true;\n        node.dt = this.dt;\n        node.jsEnd = node.start = this.startTime;\n        node[INTERACTION][REMAINING]++;\n      }\n    }, this.featureName, xhrEE);\n    register('xhr-resolved', function () {\n      var node = this[SPA_NODE];\n      if (node) {\n        if (!shouldCollectEvent(this.params)) {\n          node.cancel();\n          return;\n        }\n        var attrs = node.attrs;\n        attrs.params = this.params;\n        attrs.metrics = this.metrics;\n        node.finish(this.endTime);\n        if (!!this.currentNode && !!this.currentNode.interaction) this.currentNode.interaction.checkFinish();\n      }\n    }, this.featureName, baseEE);\n\n    /**\n     * *** JSONP ***\n     *\n     */\n\n    register('new-jsonp', function (url) {\n      if (state.currentNode) {\n        var node = this[JSONP_NODE] = state.currentNode.child('ajax', this[FETCH_START]);\n        node.start = this['new-jsonp'];\n        this.url = url;\n        this.status = null;\n      }\n    }, this.featureName, jsonpEE);\n    register('cb-start', function (args) {\n      var node = this[JSONP_NODE];\n      if (node) {\n        setCurrentNode(node);\n        this.status = 200;\n      }\n    }, this.featureName, jsonpEE);\n    register('jsonp-error', function () {\n      var node = this[JSONP_NODE];\n      if (node) {\n        setCurrentNode(node);\n        this.status = 0;\n      }\n    }, this.featureName, jsonpEE);\n    register(JSONP_END, function () {\n      var node = this[JSONP_NODE];\n      if (node) {\n        // if no status is set then cb never fired - so it's not a valid JSONP\n        if (this.status === null) {\n          node.cancel();\n          return;\n        }\n        var attrs = node.attrs;\n        var params = attrs.params = {};\n        var parsed = parseUrl(this.url);\n        params.method = 'GET';\n        params.pathname = parsed.pathname;\n        params.host = parsed.hostname + ':' + parsed.port;\n        params.status = this.status;\n        attrs.metrics = {\n          txSize: 0,\n          rxSize: 0\n        };\n        attrs.isJSONP = true;\n        node.jsEnd = this[JSONP_END];\n        node.jsTime = this[CB_START] ? this[JSONP_END] - this[CB_START] : 0;\n        node.finish(node.jsEnd);\n      }\n    }, this.featureName, jsonpEE);\n    register(FETCH_START, function (fetchArguments, dtPayload) {\n      if (fetchArguments) {\n        if (!state.disableSpaFix && !state.currentNode && state.prevInteraction && !state.prevInteraction.ignored) {\n          /*\n           * The previous interaction was discarded before a route change. Restore the interaction\n           * in case this XHR is associated with a route change.\n           */\n          const interaction = state.prevInteraction;\n          state.currentNode = interaction.root;\n          interaction.root.end = null;\n        }\n        if (state.currentNode) {\n          this[SPA_NODE] = state.currentNode.child('ajax', this[FETCH_START]);\n          if (dtPayload && this[SPA_NODE]) this[SPA_NODE].dt = dtPayload;\n        }\n      }\n    }, this.featureName, fetchEE);\n    register(FETCH_BODY + 'start', function (args) {\n      if (state.currentNode) {\n        this[SPA_NODE] = state.currentNode;\n        state.currentNode[INTERACTION][REMAINING]++;\n      }\n    }, this.featureName, fetchEE);\n    register(FETCH_BODY + 'end', function (args, ctx, bodyPromise) {\n      var node = this[SPA_NODE];\n      if (node) node[INTERACTION][REMAINING]--;\n    }, this.featureName, fetchEE);\n    register(FETCH_DONE, function (err, res) {\n      var node = this[SPA_NODE];\n      if (node) {\n        if (err || !shouldCollectEvent(this.params)) {\n          node.cancel();\n          return;\n        }\n        var attrs = node.attrs;\n        attrs.params = this.params;\n        attrs.metrics = {\n          txSize: this.txSize,\n          rxSize: this.rxSize\n        };\n        attrs.isFetch = true;\n        node.finish(this[FETCH_DONE]);\n      }\n    }, this.featureName, fetchEE);\n    register('newURL', function (url, hashChangedDuringCb) {\n      if (state.currentNode) {\n        state.currentNode[INTERACTION].setNewURL(url);\n      } else if (state.prevInteraction && !state.prevInteraction.ignored) {\n        /*\n         * The previous interaction was discarded before the route was changed. This can happen in SPA\n         * frameworks when using lazy loading. We have also seen this in version 11+ of Nextjs where\n         * some route changes re-use cached resolved promises.\n         */\n        const interaction = state.prevInteraction;\n        interaction.setNewURL(url);\n        interaction.root.end = null;\n        setCurrentNode(interaction.root);\n      }\n      if (state.currentNode) {\n        if (state.lastSeenUrl !== url) {\n          state.currentNode[INTERACTION].routeChange = true;\n        }\n        if (hashChangedDuringCb) {\n          state.nodeOnLastHashUpdate = state.currentNode;\n        }\n      }\n      state.lastSeenUrl = url;\n    }, this.featureName, historyEE);\n\n    /**\n     * SCRIPTS\n     *   This is only needed to keep the interaction open while external scripts are being loaded.\n     *   The script that is loaded could continue the interaction by making additional AJAX\n     *   calls or changing the URL. The interaction context (currentNode) needs to be\n     *   restored somehow, but this differs based on the specific customer code. In some cases, we\n     *   could wrap a JSONP callback, in other cases we could wrap a higher-level API, and in\n     *   some cases we may not be able to restore context automatically (customer would need\n     *   to instrument their code manually).\n     *\n     * - We do not restore the original context in the load/error callbacks. This would not\n     *   work for the scripts themselves because by the time the load event fires, the\n     *   script content has already been executed.\n     */\n\n    // dom-start is emitted when appendChild or replaceChild are called. If the element being\n    // inserted is script and we are inside an interaction, we will keep the interaction open\n    // until the script is loaded.\n    jsonpEE.on('dom-start', function (args) {\n      if (!state.currentNode) return;\n      var el = args[0];\n      var isScript = el && el.nodeName === 'SCRIPT' && el.src !== '';\n      var interaction = state.currentNode.interaction;\n      if (isScript) {\n        // increase remaining count to keep the interaction open\n        interaction[REMAINING]++;\n        el.addEventListener('load', onload, eventListenerOpts(false));\n        el.addEventListener('error', onerror, eventListenerOpts(false));\n      }\n      function onload() {\n        // decrease remaining to allow interaction to finish\n        interaction[REMAINING]--;\n\n        // checkFinish is what initiates closing interaction, but is only called\n        // when setCurrentNode is called. Since we are not restoring a node here,\n        // we need to initiate the check manually.\n        // The reason we are not restoring the node here is because 1) this is not\n        // where the code of the external script runs (by the time the load event\n        // fires, it has already executed), and 2) it would require storing the context\n        // probably on the DOM node and restoring in all callbacks, which is a different\n        // use case than lazy loading.\n        interaction.checkFinish();\n      }\n      function onerror() {\n        interaction[REMAINING]--;\n        interaction.checkFinish();\n      }\n    });\n    register(FN_START, function () {\n      setCurrentNode(state.prevNode);\n    }, this.featureName, mutationEE);\n    register('resolve-start', resolvePromise, this.featureName, promiseEE);\n    register('executor-err', resolvePromise, this.featureName, promiseEE);\n    register('propagate', saveNode, this.featureName, promiseEE);\n    register(CB_START, function () {\n      var ctx = this.getCtx ? this.getCtx() : this;\n      setCurrentNode(ctx[SPA_NODE]);\n    }, this.featureName, promiseEE);\n    register(INTERACTION_API + 'get', function (t) {\n      var interaction;\n      if (state?.currentNode?.[INTERACTION]) interaction = this.ixn = state.currentNode[INTERACTION];else if (state?.prevNode?.end === null && state?.prevNode?.[INTERACTION]?.root?.[INTERACTION]?.eventName !== 'initialPageLoad') interaction = this.ixn = state.prevNode[INTERACTION];else interaction = this.ixn = new Interaction('api', t, state.lastSeenUrl, state.lastSeenRouteName, onInteractionFinished, agentIdentifier);\n      if (!state.currentNode) {\n        interaction.checkFinish();\n        if (state.depth) setCurrentNode(interaction.root);\n      }\n    }, this.featureName, baseEE);\n    register(INTERACTION_API + 'actionText', function (t, actionText) {\n      var customAttrs = this.ixn.root.attrs.custom;\n      if (actionText) customAttrs.actionText = actionText;\n    }, this.featureName, baseEE);\n    register(INTERACTION_API + 'setName', function (t, name, trigger) {\n      var attrs = this.ixn.root.attrs;\n      if (name) attrs.customName = name;\n      if (trigger) attrs.trigger = trigger;\n    }, this.featureName, baseEE);\n    register(INTERACTION_API + 'setAttribute', function (t, name, value) {\n      this.ixn.root.attrs.custom[name] = value;\n    }, this.featureName, baseEE);\n    register(INTERACTION_API + 'end', function (timestamp) {\n      var interaction = this.ixn;\n      var node = activeNodeFor(interaction);\n      setCurrentNode(null);\n      node.child('customEnd', timestamp).finish(timestamp);\n      interaction.finish();\n    }, this.featureName, baseEE);\n    register(INTERACTION_API + 'ignore', function (t) {\n      this.ixn.ignored = true;\n    }, this.featureName, baseEE);\n    register(INTERACTION_API + 'save', function (t) {\n      this.ixn.save = true;\n    }, this.featureName, baseEE);\n    register(INTERACTION_API + 'tracer', function (timestamp, name, store) {\n      var interaction = this.ixn;\n      var parent = activeNodeFor(interaction);\n      var ctx = baseEE.context(store);\n      if (!name) {\n        ctx.inc = ++interaction[REMAINING];\n        return ctx[SPA_NODE] = parent;\n      }\n      ctx[SPA_NODE] = parent.child('customTracer', timestamp, name);\n    }, this.featureName, baseEE);\n    register(FN_START, tracerDone, this.featureName, tracerEE);\n    register('no-' + FN_START, tracerDone, this.featureName, tracerEE);\n    function tracerDone(timestamp, interactionContext, hasCb) {\n      var node = this[SPA_NODE];\n      if (!node) return;\n      var interaction = node[INTERACTION];\n      var inc = this.inc;\n      this.isTraced = true;\n      if (inc) {\n        interaction[REMAINING]--;\n      } else if (node) {\n        node.finish(timestamp);\n      }\n      hasCb ? setCurrentNode(node) : interaction.checkFinish();\n    }\n    register(INTERACTION_API + 'getContext', function (t, cb) {\n      var store = this.ixn.root.attrs.store;\n      setTimeout(function () {\n        cb(store);\n      }, 0);\n    }, this.featureName, baseEE);\n    register(INTERACTION_API + 'onEnd', function (t, cb) {\n      this.ixn.handlers.push(cb);\n    }, this.featureName, baseEE);\n    register('api-routeName', function (t, currentRouteName) {\n      state.lastSeenRouteName = currentRouteName;\n      if (state.currentNode) state.currentNode[INTERACTION].setNewRoute(currentRouteName);\n    }, this.featureName, baseEE);\n    function activeNodeFor(interaction) {\n      return state.currentNode && state.currentNode[INTERACTION] === interaction ? state.currentNode : interaction.root;\n    }\n    function saveNode(val, overwrite) {\n      if (overwrite || !this[SPA_NODE]) this[SPA_NODE] = state.currentNode;\n    }\n    function resolvePromise() {\n      if (!this.resolved) {\n        this.resolved = true;\n        this[SPA_NODE] = state.currentNode;\n      }\n    }\n    function getCurrentNode() {\n      return state.currentNode;\n    }\n    function setCurrentNode(newNode) {\n      if (!state.pageLoaded && !newNode && state.initialPageLoad) newNode = state.initialPageLoad.root;\n      if (state.currentNode) {\n        state.currentNode[INTERACTION].checkFinish();\n      }\n      state.prevNode = state.currentNode;\n      state.currentNode = newNode && !newNode[INTERACTION].root.end ? newNode : null;\n    }\n    function onInteractionFinished(interaction) {\n      if (interaction === state.initialPageLoad) state.initialPageLoad = null;\n      var root = interaction.root;\n      var attrs = root.attrs;\n\n      // make sure that newrelic[INTERACTION]() works in end handler\n      state.currentNode = root;\n      mapOwn(interaction.handlers, function (i, cb) {\n        cb(attrs.store);\n      });\n      setCurrentNode(null);\n    }\n    function onHarvestStarted(options) {\n      if (state.interactionsToHarvest.length === 0 || blocked) return {};\n      var payload = serializer.serializeMultiple(state.interactionsToHarvest, 0, navTiming);\n      if (options.retry) {\n        state.interactionsToHarvest.forEach(function (interaction) {\n          state.interactionsSent.push(interaction);\n        });\n      }\n      state.interactionsToHarvest = [];\n      return {\n        body: {\n          e: payload\n        }\n      };\n    }\n    function onHarvestFinished(result) {\n      if (result.sent && result.retry && state.interactionsSent.length > 0) {\n        state.interactionsSent.forEach(function (interaction) {\n          state.interactionsToHarvest.unshift(interaction);\n        });\n        state.interactionsSent = [];\n      }\n    }\n    baseEE.on('errorAgg', function (type, name, params, metrics) {\n      if (!state.currentNode) return;\n      params._interactionId = state.currentNode.interaction.id;\n      // do not capture parentNodeId when in root node\n      if (state.currentNode.type && state.currentNode.type !== 'interaction') {\n        params._interactionNodeId = state.currentNode.id;\n      }\n    });\n    baseEE.on('interaction', saveInteraction);\n    function getActionText(node) {\n      var nodeType = node.tagName.toLowerCase();\n      var goodNodeTypes = ['a', 'button', 'input'];\n      var isGoodNode = goodNodeTypes.indexOf(nodeType) !== -1;\n      if (isGoodNode) {\n        return node.title || node.value || node.innerText;\n      }\n    }\n    function saveInteraction(interaction) {\n      if (interaction.ignored || !interaction.save && !interaction.routeChange) {\n        baseEE.emit('interactionDiscarded', [interaction]);\n        return;\n      }\n      if (state.prevInteraction === interaction) {\n        // If the interaction is being saved, remove it from prevInteraction variable\n        // to prevent the interaction from possibly being sent twice or causing an internal\n        // recursive loop issue.\n        state.prevInteraction = null;\n      }\n\n      // assign unique id, this is serialized and used to link interactions with errors\n      interaction.root.attrs.id = generateUuid();\n      if (interaction.root.attrs.trigger === 'initialPageLoad') {\n        interaction.root.attrs.firstPaint = firstPaint.current.value;\n        interaction.root.attrs.firstContentfulPaint = firstContentfulPaint.current.value;\n      }\n      baseEE.emit('interactionSaved', [interaction]);\n      state.interactionsToHarvest.push(interaction);\n      scheduler.scheduleHarvest(0);\n    }\n    function isEnabled() {\n      var enabled = getConfigurationValue(agentIdentifier, 'spa.enabled');\n      return enabled !== false;\n    }\n    this.drain();\n  }\n}","import unsupportedIterableToArray from \"./unsupportedIterableToArray.js\";\nexport default function _createForOfIteratorHelper(o, allowArrayLike) {\n  var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n  if (!it) {\n    if (Array.isArray(o) || (it = unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n      var F = function F() {};\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n  var normalCompletion = true,\n    didErr = false,\n    err;\n  return {\n    s: function s() {\n      it = it.call(o);\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it[\"return\"] != null) it[\"return\"]();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}"],"names":["denyList","shouldCollectEvent","params","length","undefined","hostname","i","parsed","domainMatchesPattern","comparePath","pathname","setDenyList","denyListConfig","url","indexOf","substring","firstSlash","host","_host$split","split","_slicedToArray","push","pattern","domain","path","HarvestScheduler","_SharedContext","_inherits","_super","_createSuper","endpoint","opts","parent","_this$sharedContext","_this","_classCallCheck","call","started","timeoutHandle","aborted","harvest","Harvest","sharedContext","subscribeToEOL","unload","bind","_assertThisInitialized","ee","on","SESSION_EVENTS","RESET","runHarvest","forceNoRetry","_createClass","key","value","this","onUnload","interval","initialDelay","scheduleHarvest","permanently","arguments","clearTimeout","delay","_this2","setTimeout","_this3","submitMethod","payload","cbRanAfterSend","result","retry","onHarvestFinished","harvests","getPayload","submitData","isFinalHarvest","Object","prototype","toString","apply","_toConsumableArray","send","args","sendX","raw","_send","forEach","cbFinished","customUrl","onFinished","sent","retryDelay","SharedContext","hasOwnProp","hasOwnProperty","MAX_ATTRIBUTES","nullable","val","fn","comma","numeric","n","noDefault","Math","floor","getAddStringContext","agentIdentifier","stringTable","create","stringTableIdx","str","obfuscator","Obfuscator","String","shouldObfuscate","obfuscateString","replace","escapable","quoteString","addCustomAttributes","attrs","addString","attrParts","mapOwn","serializedValue","type","stringify","isWorkerScope","globalScope","cleanupTasks","origClose","close","_step","_iterator","_createForOfIteratorHelper","s","done","task","err","e","f","cb","isBrowserScope","subscribeToVisibilityChange","windowAddEventListener","lastId","InteractionNode","interaction","timestamp","defineProperty","writable","id","children","end","jsEnd","start","jsTime","cancelled","InteractionNodePrototype","child","name","dontWait","nodes","onNodeAdded","node","remaining","callback","exclusiveTime","lastCb","cancel","finish","_parent","lastFinish","checkFinish","originalSetTimeout","originals","ST","originalClearTimeout","CT","Interaction","eventName","routeName","get","finishTimer","checkingFinish","handlers","root","trigger","initialPageURL","getRuntime","origin","oldRoute","newURL","oldURL","custom","store","InteractionPrototype","_resetFinishCheck","setNewURL","setNewRoute","route","newRoute","endTimestamp","max","customAttrs","getInfo","jsAttributes","attr","emit","Serializer","firstTimestamp","interactions","offset","navTiming","info","serialized","serializeInteraction","routeChange","isRouteChange","isInitialPage","typeIdsByName","ajax","customTracer","includeHashFragment","addNode","nodeList","typeName","typeId","startTimestamp","childCount","attrCount","apmAttributes","atts","hasNavTiming","metrics","queueTime","appTime","applicationTime","fields","cleanURL","customName","firstPaint","firstContentfulPaint","concat","method","status","txSize","rxSize","isFetch","isJSONP","dt","spanId","traceId","keys","gql","ajaxAttrParts","tracedTime","unshift","join","seperator","navTimingNode","prev","slice","v","FEATURE_NAME","CONSTANTS","INTERACTION_EVENTS","MAX_TIMER_BUDGET","FN_START","FN_END","CB_START","INTERACTION_API","REMAINING","INTERACTION","SPA_NODE","JSONP_NODE","FETCH_START","FETCH_DONE","FETCH_BODY","JSONP_END","Aggregate","_AggregateBase","aggregator","state","lastSeenUrl","lastSeenRouteName","timerMap","timerBudget","currentNode","prevNode","nodeOnLastHashUpdate","initialPageLoad","pageLoaded","childTime","depth","harvestTimeSeconds","getConfigurationValue","interactionsToHarvest","interactionsSent","disableSpaFix","serializer","_assertThisInitialize","blocked","baseEE","mutationEE","promiseEE","historyEE","eventsEE","timerEE","fetchEE","jsonpEE","xhrEE","tracerEE","scheduler","options","serializeMultiple","body","register","stopTimer","featureName","_possibleConstructorReturn","onInteractionFinished","save","prevInteraction","callbackStart","pluginApi","getCurrentNode","setCurrentNode","ct","callbackEnd","totalTime","isTraced","tracerDone","interactionContext","hasCb","inc","activeNodeFor","resolvePromise","resolved","newNode","init","FEATURE_NAMES","spa","eventSource","ev","evName","eventNode","bundleId","window","XMLHttpRequest","context","spaNode","ixn","nodeType","tagName","toLowerCase","title","innerText","getActionText","target","actionText","obj","timerId","timerDuration","Function","ignored","startTime","endTime","parseUrl","port","fetchArguments","dtPayload","ctx","bodyPromise","res","hashChangedDuringCb","el","isScript","nodeName","src","addEventListener","eventListenerOpts","overwrite","getCtx","t","_state$currentNode","_state$prevNode","_state$prevNode2","currentRouteName","_interactionId","_interactionNodeId","generateUuid","current","drain","AggregateBase","_defineProperty","o","allowArrayLike","it","Symbol","iterator","Array","isArray","F","_e","TypeError","normalCompletion","didErr","step","next","_e2"],"sourceRoot":""}