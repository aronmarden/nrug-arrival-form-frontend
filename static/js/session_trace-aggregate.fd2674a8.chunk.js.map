{"version":3,"file":"static/js/session_trace-aggregate.fd2674a8.chunk.js","mappings":"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","sources":["../node_modules/@newrelic/browser-agent/dist/esm/common/constants/shared-channel.js","../node_modules/@newrelic/browser-agent/dist/esm/common/harvest/harvest-scheduler.js","../node_modules/@newrelic/browser-agent/dist/esm/common/unload/eol.js","../node_modules/@babel/runtime/helpers/esm/classPrivateFieldSet.js","../node_modules/@babel/runtime/helpers/esm/classApplyDescriptorSet.js","../node_modules/@newrelic/browser-agent/dist/esm/features/utils/handler-cache.js","../node_modules/@newrelic/browser-agent/dist/esm/features/session_replay/replay-mode.js","../node_modules/@newrelic/browser-agent/dist/esm/features/session_trace/aggregate/index.js","../node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js"],"sourcesContent":["/**\n * @file Keeps an object alive that is passed to all feature aggregate modules.\n * The purpose is to have a way for communication and signals to relay across features at runtime.\n * This object can hold any arbitrary values and should be treated as on-the-fly dynamic.\n */\n\nlet onReplayReady;\nconst sessionReplayInitialized = new Promise(resolve => {\n  onReplayReady = resolve;\n});\nexport const sharedChannel = Object.freeze({\n  onReplayReady,\n  sessionReplayInitialized\n});","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport * as submitData from '../util/submit-data';\nimport { SharedContext } from '../context/shared-context';\nimport { Harvest } from './harvest';\nimport { subscribeToEOL } from '../unload/eol';\nimport { SESSION_EVENTS } from '../session/session-entity';\n\n/**\n * Periodically invokes harvest calls and handles retries\n */\nexport class HarvestScheduler extends SharedContext {\n  /**\n     * Create a HarvestScheduler\n     * @param {string} endpoint - The base BAM endpoint name -- ex. 'events'\n     * @param {object} opts - The options used to configure the HarvestScheduler\n     * @param {Function} opts.onFinished - The callback to be fired when a harvest has finished\n     * @param {Function} opts.getPayload - A callback which can be triggered to return a payload for harvesting\n     * @param {number} opts.retryDelay - The number of seconds to wait before retrying after a network failure\n     * @param {boolean} opts.raw - Use a prefabricated payload shape as the harvest payload without the need for formatting\n     * @param {string} opts.customUrl - A custom url that falls outside of the shape of the standard BAM harvester url pattern.  Will use directly instead of concatenating various pieces\n     * @param {*} parent - The parent object, whose state can be passed into SharedContext\n     */\n  constructor(endpoint, opts, parent) {\n    super(parent); // gets any allowed properties from the parent and stores them in `sharedContext`\n    this.endpoint = endpoint;\n    this.opts = opts || {};\n    this.started = false;\n    this.timeoutHandle = null;\n    this.aborted = false; // this controls the per-interval and final harvests for the scheduler (currently per feature specific!)\n\n    this.harvest = new Harvest(this.sharedContext);\n\n    // unload if EOL mechanism fires\n    subscribeToEOL(this.unload.bind(this));\n\n    /* Flush all buffered data if session resets and give up retries. This should be synchronous to ensure that the correct `session` value is sent.\n      Since session-reset generates a new session ID and the ID is grabbed at send-time, any delays or retries would cause the payload to be sent under\n      the wrong session ID. */\n    this.sharedContext?.ee.on(SESSION_EVENTS.RESET, () => this.runHarvest({\n      forceNoRetry: true\n    }));\n  }\n\n  /**\n   * This function is only meant for the last outgoing harvest cycle of a page. It trickles down to using sendBeacon, which should not be used\n   * to send payloads while the page is still active, due to limitations on how much data can be buffered in the API at any one time.\n   */\n  unload() {\n    if (this.aborted) return;\n    // If opts.onUnload is defined, these are special actions to execute before attempting to send the final payload.\n    if (this.opts.onUnload) this.opts.onUnload();\n    this.runHarvest({\n      unload: true\n    });\n  }\n  startTimer(interval, initialDelay) {\n    this.interval = interval;\n    this.started = true;\n    this.scheduleHarvest(initialDelay != null ? initialDelay : this.interval);\n  }\n  stopTimer() {\n    let permanently = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    this.aborted = permanently; // stopping permanently is same as aborting, but this function also cleans up the setTimeout loop\n    this.started = false;\n    if (this.timeoutHandle) {\n      clearTimeout(this.timeoutHandle);\n    }\n  }\n  scheduleHarvest(delay, opts) {\n    if (this.timeoutHandle) return;\n    if (delay == null) {\n      delay = this.interval;\n    }\n    this.timeoutHandle = setTimeout(() => {\n      this.timeoutHandle = null;\n      this.runHarvest(opts);\n    }, delay * 1000);\n  }\n  runHarvest(opts) {\n    if (this.aborted) return;\n\n    /**\n     * This is executed immediately after harvest sends the data via XHR, or if there's nothing to send. Note that this excludes on unloading / sendBeacon.\n     * @param {Object} result\n     */\n    const cbRanAfterSend = result => {\n      if (opts?.forceNoRetry) result.retry = false; // discard unsent data rather than re-queuing for next harvest attempt\n      this.onHarvestFinished(opts, result);\n    };\n    let harvests = [];\n    let submitMethod;\n    let payload;\n    if (this.opts.getPayload) {\n      // Ajax & PVT & SR features provide a callback function to get data for harvesting\n      submitMethod = submitData.getSubmitMethod({\n        isFinalHarvest: opts?.unload\n      });\n      if (!submitMethod) return false;\n      const retry = !opts?.unload && submitMethod === submitData.xhr;\n      payload = this.opts.getPayload({\n        retry\n      });\n      if (!payload) {\n        if (this.started) {\n          this.scheduleHarvest();\n        }\n        return;\n      }\n      payload = Object.prototype.toString.call(payload) === '[object Array]' ? payload : [payload];\n      harvests.push(...payload);\n    }\n\n    /** sendX is used for features that do not supply a preformatted payload via \"getPayload\" */\n    let send = args => this.harvest.sendX(args);\n    if (harvests.length) {\n      /** _send is the underlying method for sending in the harvest, if sending raw we can bypass the other helpers completely which format the payloads */\n      if (this.opts.raw) send = args => this.harvest._send(args);\n      /** send is used to formated the payloads from \"getPayload\" and obfuscate before sending */else send = args => this.harvest.send(args);\n    } else {\n      // force it to run at least once in sendX mode\n      harvests.push(undefined);\n    }\n    harvests.forEach(payload => {\n      send({\n        endpoint: this.endpoint,\n        payload,\n        opts,\n        submitMethod,\n        cbFinished: cbRanAfterSend,\n        customUrl: this.opts.customUrl,\n        raw: this.opts.raw\n      });\n    });\n    if (this.started) {\n      this.scheduleHarvest();\n    }\n  }\n  onHarvestFinished(opts, result) {\n    if (this.opts.onFinished) {\n      this.opts.onFinished(result);\n    }\n    if (result.sent && result.retry) {\n      const delay = result.delay || this.opts.retryDelay;\n      // reschedule next harvest if should be delayed longer\n      if (this.started && delay) {\n        clearTimeout(this.timeoutHandle);\n        this.timeoutHandle = null;\n        this.scheduleHarvest(delay, opts);\n      } else if (!this.started && delay) {\n        // if not running on a timer, schedule a single retry\n        this.scheduleHarvest(delay, opts);\n      }\n    }\n  }\n}","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { windowAddEventListener } from '../event-listener/event-listener-opts';\nimport { globalScope, isWorkerScope, isBrowserScope } from '../constants/runtime';\nimport { subscribeToVisibilityChange } from '../window/page-visibility';\nif (isWorkerScope) {\n  globalScope.cleanupTasks = []; // create new list on WorkerGlobalScope to track funcs to run before exiting thread\n\n  const origClose = globalScope.close;\n  globalScope.close = () => {\n    // on worker's EoL signal, execute all \"listeners\", e.g. final harvests\n    for (let task of globalScope.cleanupTasks) {\n      task();\n    }\n    origClose();\n  };\n}\n\n/**\n * Subscribes a provided callback to the time/event when the agent should treat it as end-of-life.\n * This is used, for example, to submit a final harvest and send all remaining data on best-effort.\n * @param {function} cb - func to run before or during the last reliable event or time of an env's life span\n */\nexport function subscribeToEOL(cb) {\n  if (isBrowserScope) {\n    subscribeToVisibilityChange(cb, true); // when user switches tab or hides window, esp. mobile scenario\n    windowAddEventListener('pagehide', cb); // when user navigates away, and because safari iOS v14.4- doesn't fully support vis change\n    // --this ought to be removed once support for version below 14.5 phases out\n  } else if (isWorkerScope) {\n    globalScope.cleanupTasks.push(cb); // close() should run these tasks before quitting thread\n  }\n  // By default (for other env), this fn has no effect.\n}","import classApplyDescriptorSet from \"./classApplyDescriptorSet.js\";\nimport classExtractFieldDescriptor from \"./classExtractFieldDescriptor.js\";\nexport default function _classPrivateFieldSet(receiver, privateMap, value) {\n  var descriptor = classExtractFieldDescriptor(receiver, privateMap, \"set\");\n  classApplyDescriptorSet(receiver, descriptor, value);\n  return value;\n}","export default function _classApplyDescriptorSet(receiver, descriptor, value) {\n  if (descriptor.set) {\n    descriptor.set.call(receiver, value);\n  } else {\n    if (!descriptor.writable) {\n      throw new TypeError(\"attempted to set read only private field\");\n    }\n    descriptor.value = value;\n  }\n}","/**\n * A class to defer callback execution until a decision can be reached\n */\nexport class HandlerCache {\n  /** @private @type {boolean | undefined} */\n  #decision = undefined;\n  /** @private @type {Function[]} */\n  #cache = [];\n  /** @private @type {Timeout} */\n  #settleTimer = setTimeout(() => this.#close(), 5000);\n  #noMoreChanges = false;\n\n  /**\n   * tell the handlerCache that its ok to immediately execute the callbacks that are triggered by the ee from this moment on\n   * and execute all the storage callbacks saved up in the handlerCache\n   * @private\n   */\n  #drain() {\n    this.#cache.forEach(h => h());\n    this.#close();\n  }\n\n  /**\n   * tell the handlerCache not to execute any of the storage callbacks\n   * and wipe out all the storage callbacks saved up in the handlerCache\n   * @private\n   */\n  #close() {\n    this.#cache = [];\n    clearTimeout(this.#settleTimer);\n  }\n\n  /**\n   * Wrap callback functions with this method to defer their execution until a decision has been reached\n   * @param {Function} handler\n   * @returns {void}\n   */\n  settle(handler) {\n    if (this.#decision === false) {\n      // Do nothing\n    } else if (this.#decision === undefined) this.#cache.push(handler);else handler();\n  }\n\n  /**\n   * Make a decision about what to do with the cache of callbacks.\n   * --- if true: tell the handlerCache that its ok to immediately execute the callbacks that are triggered by the ee from this moment on\n   * and execute all the storage callbacks saved up in the handlerCache ---\n   * --- if false: tell the handlerCache not to execute any of the storage callbacks\n   * and wipe out all the storage callbacks saved up in the handlerCache\n   * @param {boolean} decision\n   */\n  decide(decision) {\n    if (this.#noMoreChanges) return;\n    this.#decision = decision;\n    if (decision === false) this.#close();\n    if (decision === true) this.#drain();\n  }\n  permanentlyDecide(decision) {\n    if (this.#noMoreChanges) return;\n    this.decide(decision);\n    this.#noMoreChanges = true;\n  }\n}","import { getConfigurationValue } from '../../common/config/config';\nimport { MODE } from '../../common/session/session-entity';\nimport { gosNREUM } from '../../common/window/nreum';\nimport { sharedChannel } from '../../common/constants/shared-channel';\n\n/**\n * Figure out if the Replay feature is running (what mode it's in).\n * IMPORTANT: Session tracking is assumed to be ON; if applicable, check init's privacy.cookies_enabled setting before using this fn!\n * CRITICAL: This fn must be called prior to ALL features aggregate draining. If not, it will never resolve.\n * @param {String} agentId\n * @returns Promise that resolves to one of the values in MODE enum\n */\nexport async function getSessionReplayMode(agentId) {\n  try {\n    const newrelic = gosNREUM();\n    // Should be enabled by configuration and using an agent build that includes it (via checking that the instrument class was initialized).\n    if (getConfigurationValue(agentId, 'session_replay.enabled') && typeof newrelic.initializedAgents[agentId].features.session_replay === 'object') {\n      const srInitialized = await newrelic.initializedAgents[agentId].features.session_replay.onAggregateImported;\n      if (srInitialized) return await sharedChannel.sessionReplayInitialized; // wait for replay to determine which mode it's after running its sampling logic\n    }\n  } catch (e) {/* exception ==> off */}\n  return MODE.OFF; // at any step of the way s.t. SR cannot be on by implication or is explicitly off\n}","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { registerHandler } from '../../../common/event-emitter/register-handler';\nimport { HarvestScheduler } from '../../../common/harvest/harvest-scheduler';\nimport { parseUrl } from '../../../common/url/parse-url';\nimport { getConfigurationValue, getRuntime } from '../../../common/config/config';\nimport { now } from '../../../common/timing/now';\nimport { FEATURE_NAME } from '../constants';\nimport { HandlerCache } from '../../utils/handler-cache';\nimport { MODE, SESSION_EVENTS } from '../../../common/session/session-entity';\nimport { getSessionReplayMode } from '../../session_replay/replay-mode';\nimport { AggregateBase } from '../../utils/aggregate-base';\nconst ignoredEvents = {\n  // we find that certain events make the data too noisy to be useful\n  global: {\n    mouseup: true,\n    mousedown: true\n  },\n  // certain events are present both in the window and in PVT metrics.  PVT metrics are prefered so the window events should be ignored\n  window: {\n    load: true,\n    pagehide: true\n  },\n  // when ajax instrumentation is disabled, all XMLHttpRequest events will return with origin = xhrOriginMissing and should be ignored\n  xhrOriginMissing: {\n    ignoreAll: true\n  }\n};\nconst toAggregate = {\n  typing: [1000, 2000],\n  scrolling: [100, 1000],\n  mousing: [1000, 2000],\n  touching: [1000, 2000]\n};\nconst MAX_TRACE_DURATION = 10 * 60 * 1000; // 10 minutes\nconst REQ_THRESHOLD_TO_SEND = 30;\nconst ERROR_MODE_SECONDS_WINDOW = 30 * 1000; // sliding window of nodes to track when simply monitoring (but not harvesting) in error mode\n\nexport class Aggregate extends AggregateBase {\n  static featureName = FEATURE_NAME;\n  #scheduler;\n  constructor(agentIdentifier, aggregator, argsObj) {\n    var _this;\n    super(agentIdentifier, aggregator, FEATURE_NAME);\n    _this = this;\n    this.agentRuntime = getRuntime(agentIdentifier);\n\n    // Very unlikely, but in case the existing XMLHttpRequest.prototype object on the page couldn't be wrapped.\n    if (!this.agentRuntime.xhrWrappable) return;\n    this.resourceObserver = argsObj?.resourceObserver; // undefined if observer couldn't be created\n    this.ptid = '';\n    this.trace = {};\n    this.nodeCount = 0;\n    this.sentTrace = null;\n    this.harvestTimeSeconds = getConfigurationValue(agentIdentifier, 'session_trace.harvestTimeSeconds') || 10;\n    this.maxNodesPerHarvest = getConfigurationValue(agentIdentifier, 'session_trace.maxNodesPerHarvest') || 1000;\n    /**\n     * Standalone (mode) refers to the legacy version of ST before the idea of 'session' or the Replay feature existed.\n     * It has some different behavior vs when used in tandem with replay. */\n    this.isStandalone = false;\n    const operationalGate = new HandlerCache(); // acts as a controller-intermediary that can enable or disable this feature's collection dynamically\n    const sessionEntity = this.agentRuntime.session;\n    this.operationalGate = operationalGate;\n\n    /* --- The following section deals with user sessions concept & contains non-trivial control flow. --- */\n    const controlTraceOp = traceMode => {\n      switch (traceMode) {\n        case MODE.ERROR:\n          this.startTracing(operationalGate, true);\n          break;\n        case MODE.FULL:\n        case true:\n          this.startTracing(operationalGate);\n          break;\n        case MODE.OFF:\n        case false:\n        default:\n          // this feature becomes \"off\" (does nothing & nothing is sent)\n          operationalGate.decide(false);\n          break;\n      }\n    };\n    if (!sessionEntity) {\n      // Since session manager isn't around, do the old Trace behavior of waiting for RUM response to decide feature activation.\n      this.isStandalone = true;\n      registerHandler('rumresp-stn', on => controlTraceOp(on), this.featureName, this.ee);\n    } else {\n      let seenAnError = false;\n      let mostRecentModeKnown;\n      registerHandler('errorAgg', () => {\n        // Switch to full capture mode on next harvest on first exception thrown only. Only done once so that sessionTraceMode isn't constantly overwritten after decision block.\n        if (!seenAnError) {\n          seenAnError = true;\n          /* If this cb executes before Trace has started, then no further action needed. But if...\n           - startTracing already ran under ERROR mode, then it will NOT have kicked off the harvest-scheduler so that needs to be done & switch mode.\n           - startTracing never ran because mode is OFF or Replay aborted or Traced turned off elsewhere OR trace already in FULL, then this should do nothing. */\n          if (sessionEntity.state.sessionTraceMode === MODE.ERROR && this.#scheduler) {\n            sessionEntity.write({\n              sessionTraceMode: mostRecentModeKnown = MODE.FULL\n            });\n            this.trimSTNs(ERROR_MODE_SECONDS_WINDOW); // up until now, Trace would've been just buffering nodes up to max, which needs to be trimmed to last X seconds\n            this.#scheduler.runHarvest({\n              needResponse: true\n            });\n          }\n        }\n      }, this.featureName, this.ee);\n      const stopTracePerm = () => {\n        if (sessionEntity.state.sessionTraceMode !== MODE.OFF) sessionEntity.write({\n          sessionTraceMode: MODE.OFF\n        });\n        operationalGate.permanentlyDecide(false);\n        if (mostRecentModeKnown === MODE.FULL) this.#scheduler?.runHarvest(); // allow queued nodes (past opGate) to final harvest, unless they were buffered in other modes\n        this.#scheduler?.stopTimer(true); // the 'true' arg here will forcibly block any future call to runHarvest, so the last runHarvest above must be prior\n        this.#scheduler = null;\n      };\n\n      // CAUTION: everything inside this promise runs post-load; event subscribers must be pre-load aka synchronous with constructor\n      this.waitForFlags(['stn', 'sr']).then(async _ref => {\n        let [traceOn, replayOn] = _ref;\n        if (!replayOn) {\n          // When sr = 0 from BCS, also do the old Trace behavior:\n          this.isStandalone = true;\n          controlTraceOp(traceOn);\n        } else {\n          this.ee.on('REPLAY_ABORTED', () => stopTracePerm());\n          /* Assuming on page visible that the trace mode is updated from shared session,\n           - if trace is turned off from the other page, it should be likewise here.\n           - if trace switches to Full mode, harvest should start (prev: Error) if not already running (prev: Full). */\n          this.ee.on(SESSION_EVENTS.RESUME, () => {\n            const updatedTraceMode = sessionEntity.state.sessionTraceMode;\n            if (updatedTraceMode === MODE.OFF) stopTracePerm();else if (updatedTraceMode === MODE.FULL && this.#scheduler && !this.#scheduler.started) this.#scheduler.runHarvest({\n              needResponse: true\n            });\n            mostRecentModeKnown = updatedTraceMode;\n          });\n          this.ee.on(SESSION_EVENTS.PAUSE, () => {\n            mostRecentModeKnown = sessionEntity.state.sessionTraceMode;\n          });\n          if (!sessionEntity.isNew) {\n            // inherit the same mode as existing session's Trace\n            if (sessionEntity.state.sessionReplayMode === MODE.OFF) this.isStandalone = true;\n            controlTraceOp(mostRecentModeKnown = sessionEntity.state.sessionTraceMode);\n          } else {\n            // for new sessions, see the truth table associated with NEWRELIC-8662 wrt the new Trace behavior under session management\n            const replayMode = await getSessionReplayMode(agentIdentifier);\n            if (replayMode === MODE.OFF) this.isStandalone = true; // without SR, Traces are still subject to old harvest limits\n\n            let startingMode;\n            if (traceOn === true) {\n              // CASE: both trace (entitlement+sampling) & replay (entitlement) flags are true from RUM\n              startingMode = MODE.FULL; // always full capture regardless of replay sampling decisions\n            } else {\n              // CASE: trace flag is off, BUT it must still run if replay is on (possibly)\n              // At this point, it's possible that 1 or more exception was thrown, in which case just start in full if Replay originally started in ERROR mode.\n              if (replayMode === MODE.ERROR && seenAnError) startingMode = MODE.FULL;else startingMode = replayMode;\n            }\n            sessionEntity.write({\n              sessionTraceMode: mostRecentModeKnown = startingMode\n            });\n            controlTraceOp(startingMode);\n          }\n        }\n      });\n    }\n    /* --- EoS --- */\n\n    // register the handlers immediately... but let the handlerCache decide if the data should actually get stored...\n    registerHandler('bst', function () {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n      return operationalGate.settle(() => _this.storeEvent(...args));\n    }, this.featureName, this.ee);\n    registerHandler('bstResource', function () {\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n      return operationalGate.settle(() => _this.storeResources(...args));\n    }, this.featureName, this.ee);\n    registerHandler('bstHist', function () {\n      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n        args[_key3] = arguments[_key3];\n      }\n      return operationalGate.settle(() => _this.storeHist(...args));\n    }, this.featureName, this.ee);\n    registerHandler('bstXhrAgg', function () {\n      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n        args[_key4] = arguments[_key4];\n      }\n      return operationalGate.settle(() => _this.storeXhrAgg(...args));\n    }, this.featureName, this.ee);\n    registerHandler('bstApi', function () {\n      for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n        args[_key5] = arguments[_key5];\n      }\n      return operationalGate.settle(() => _this.storeSTN(...args));\n    }, this.featureName, this.ee);\n    registerHandler('errorAgg', function () {\n      for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n        args[_key6] = arguments[_key6];\n      }\n      return operationalGate.settle(() => _this.storeErrorAgg(...args));\n    }, this.featureName, this.ee);\n    registerHandler('pvtAdded', function () {\n      for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {\n        args[_key7] = arguments[_key7];\n      }\n      return operationalGate.settle(() => _this.processPVT(...args));\n    }, this.featureName, this.ee);\n    this.drain();\n  }\n  startTracing(startupBuffer) {\n    let dontStartHarvestYet = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    if (typeof PerformanceNavigationTiming !== 'undefined') {\n      this.storeTiming(window.performance.getEntriesByType('navigation')[0]);\n    } else {\n      this.storeTiming(window.performance.timing);\n    }\n    this.#scheduler = new HarvestScheduler('resources', {\n      onFinished: this.#onHarvestFinished.bind(this),\n      retryDelay: this.harvestTimeSeconds\n    }, this);\n    this.#scheduler.harvest.on('resources', this.#prepareHarvest.bind(this));\n    if (dontStartHarvestYet === false) this.#scheduler.runHarvest({\n      needResponse: true\n    }); // sends first stn harvest immediately\n    startupBuffer.decide(true); // signal to ALLOW & process data in EE's buffer into internal nodes queued for next harvest\n  }\n\n  #onHarvestFinished(result) {\n    if (result.sent && result.responseText && !this.ptid) {\n      // continue interval harvest only if ptid was returned by server on the first\n      this.agentRuntime.ptid = this.ptid = result.responseText;\n      this.#scheduler.startTimer(this.harvestTimeSeconds);\n    }\n    if (result.sent && result.retry && this.sentTrace) {\n      // merge previous trace back into buffer to retry for next harvest\n      Object.entries(this.sentTrace).forEach(_ref2 => {\n        let [name, listOfSTNodes] = _ref2;\n        if (this.nodeCount >= this.maxNodesPerHarvest) return;\n        this.nodeCount += listOfSTNodes.length;\n        this.trace[name] = this.trace[name] ? listOfSTNodes.concat(this.trace[name]) : listOfSTNodes;\n      });\n      this.sentTrace = null;\n    }\n  }\n  #prepareHarvest(options) {\n    if (this.isStandalone) {\n      if (this.ptid && now() >= MAX_TRACE_DURATION) {\n        // Perform a final harvest once we hit or exceed the max session trace time\n        options.isFinalHarvest = true;\n        this.operationalGate.permanentlyDecide(false);\n        this.#scheduler.stopTimer(true);\n      } else if (this.ptid && this.nodeCount <= REQ_THRESHOLD_TO_SEND && !options.isFinalHarvest) {\n        // Only harvest when more than some threshold of nodes are pending, after the very first harvest, with the exception of the last outgoing harvest.\n        return;\n      }\n    } else {\n      //   -- *cli May '26 - Update: Not rate limiting backgrounded pages either for now.\n      //   if (this.ptid && document.visibilityState === 'hidden' && this.nodeCount <= REQ_THRESHOLD_TO_SEND) return\n\n      const currentMode = this.agentRuntime.session.state.sessionTraceMode;\n      /* There could still be nodes previously collected even after Trace (w/ session mgmt) is turned off. Hence, continue to send the last batch.\n       * The intermediary controller SHOULD be already switched off so that no nodes are further queued. */\n      if (currentMode === MODE.OFF && Object.keys(this.trace).length === 0) return;\n      if (currentMode === MODE.ERROR) return; // Trace in this mode should never be harvesting, even on unload\n    }\n\n    return this.takeSTNs(options.retry);\n  }\n\n  // PageViewTiming (FEATURE) events and metrics, such as 'load', 'lcp', etc. pipes into ST here.\n  processPVT(name, value, attrs) {\n    this.storeTiming({\n      [name]: value\n    });\n    if (hasFID(name, attrs)) this.storeEvent({\n      type: 'fid',\n      target: 'document'\n    }, 'document', value, value + attrs.fid);\n    function hasFID(name, attrs) {\n      return name === 'fi' && !!attrs && typeof attrs.fid === 'number';\n    }\n  }\n\n  // This processes the aforementioned PVT and the first navigation entry of the page.\n  storeTiming(timingEntry) {\n    if (!timingEntry) return;\n\n    // loop iterates through prototype also (for FF)\n    for (let key in timingEntry) {\n      let val = timingEntry[key];\n\n      // ignore size and status type nodes that do not map to timestamp metrics\n      const lck = key.toLowerCase();\n      if (lck.indexOf('size') >= 0 || lck.indexOf('status') >= 0) continue;\n\n      // ignore inherited methods, meaningless 0 values, and bogus timestamps\n      // that are in the future (Microsoft Edge seems to sometimes produce these)\n      if (!(typeof val === 'number' && val >= 0)) continue;\n      val = Math.round(val);\n      this.storeSTN({\n        n: key,\n        s: val,\n        e: val,\n        o: 'document',\n        t: 'timing'\n      });\n    }\n  }\n\n  // Tracks the events and their listener's duration on objects wrapped by wrap-events.\n  storeEvent(currentEvent, target, start, end) {\n    if (this.shouldIgnoreEvent(currentEvent, target)) return;\n    const evt = {\n      n: this.evtName(currentEvent.type),\n      s: start,\n      e: end,\n      t: 'event'\n    };\n    try {\n      // webcomponents-lite.js can trigger an exception on currentEvent.target getter because\n      // it does not check currentEvent.currentTarget before calling getRootNode() on it\n      evt.o = this.evtOrigin(currentEvent.target, target);\n    } catch (e) {\n      evt.o = this.evtOrigin(null, target);\n    }\n    this.storeSTN(evt);\n  }\n  shouldIgnoreEvent(event, target) {\n    const origin = this.evtOrigin(event.target, target);\n    if (event.type in ignoredEvents.global) return true;\n    if (!!ignoredEvents[origin] && ignoredEvents[origin].ignoreAll) return true;\n    return !!(!!ignoredEvents[origin] && event.type in ignoredEvents[origin]);\n  }\n  evtName(type) {\n    switch (type) {\n      case 'keydown':\n      case 'keyup':\n      case 'keypress':\n        return 'typing';\n      case 'mousemove':\n      case 'mouseenter':\n      case 'mouseleave':\n      case 'mouseover':\n      case 'mouseout':\n        return 'mousing';\n      case 'scroll':\n        return 'scrolling';\n      case 'touchstart':\n      case 'touchmove':\n      case 'touchend':\n      case 'touchcancel':\n      case 'touchenter':\n      case 'touchleave':\n        return 'touching';\n      default:\n        return type;\n    }\n  }\n  evtOrigin(t, target) {\n    let origin = 'unknown';\n    if (t && t instanceof XMLHttpRequest) {\n      const params = this.ee.context(t).params;\n      if (!params || !params.status || !params.method || !params.host || !params.pathname) return 'xhrOriginMissing';\n      origin = params.status + ' ' + params.method + ': ' + params.host + params.pathname;\n    } else if (t && typeof t.tagName === 'string') {\n      origin = t.tagName.toLowerCase();\n      if (t.id) origin += '#' + t.id;\n      if (t.className) {\n        for (let i = 0; i < t.classList.length; i++) origin += '.' + t.classList[i];\n      }\n    }\n    if (origin === 'unknown') {\n      if (typeof target === 'string') origin = target;else if (target === document) origin = 'document';else if (target === window) origin = 'window';else if (target instanceof FileReader) origin = 'FileReader';\n    }\n    return origin;\n  }\n\n  // Tracks when the window history API specified by wrap-history is used.\n  storeHist(path, old, time) {\n    const node = {\n      n: 'history.pushState',\n      s: time,\n      e: time,\n      o: path,\n      t: old\n    };\n    this.storeSTN(node);\n  }\n  #laststart = 0;\n  // Processes all the PerformanceResourceTiming entries captured (by observer).\n  storeResources(resources) {\n    if (!resources || resources.length === 0) return;\n    resources.forEach(currentResource => {\n      if ((currentResource.fetchStart | 0) <= this.#laststart) return; // don't recollect already-seen resources\n\n      const parsed = parseUrl(currentResource.name);\n      const res = {\n        n: currentResource.initiatorType,\n        s: currentResource.fetchStart | 0,\n        e: currentResource.responseEnd | 0,\n        o: parsed.protocol + '://' + parsed.hostname + ':' + parsed.port + parsed.pathname,\n        // resource.name is actually a URL so it's the source\n        t: currentResource.entryType\n      };\n      this.storeSTN(res);\n    });\n    this.#laststart = resources[resources.length - 1].fetchStart | 0;\n  }\n\n  // JavascriptError (FEATURE) events pipes into ST here.\n  storeErrorAgg(type, name, params, metrics) {\n    if (type !== 'err') return; // internal errors are purposefully ignored\n    const node = {\n      n: 'error',\n      s: metrics.time,\n      e: metrics.time,\n      o: params.message,\n      t: params.stackHash\n    };\n    this.storeSTN(node);\n  }\n\n  // Ajax (FEATURE) events--XML & fetches--pipes into ST here.\n  storeXhrAgg(type, name, params, metrics) {\n    if (type !== 'xhr') return;\n    const node = {\n      n: 'Ajax',\n      s: metrics.time,\n      e: metrics.time + metrics.duration,\n      o: params.status + ' ' + params.method + ': ' + params.host + params.pathname,\n      t: 'ajax'\n    };\n    this.storeSTN(node);\n  }\n\n  // Central function called by all the other store__ & addToTrace API to append a trace node.\n  storeSTN(stn) {\n    if (this.nodeCount >= this.maxNodesPerHarvest) {\n      // limit the amount of pending data awaiting next harvest\n      if (this.isStandalone || this.agentRuntime.session.state.sessionTraceMode !== MODE.ERROR) return;\n      const openedSpace = this.trimSTNs(ERROR_MODE_SECONDS_WINDOW); // but maybe we could make some space by discarding irrelevant nodes if we're in sessioned Error mode\n      if (openedSpace === 0) return;\n    }\n    if (this.isStandalone && now() >= MAX_TRACE_DURATION) {\n      return;\n    }\n    if (this.trace[stn.n]) this.trace[stn.n].push(stn);else this.trace[stn.n] = [stn];\n    this.nodeCount++;\n  }\n\n  /**\n   * Trim the collection of nodes awaiting harvest such that those seen outside a certain span of time are discarded.\n   * @param {number} lookbackDuration Past length of time until now for which we care about nodes, in milliseconds\n   * @returns {number} However many nodes were discarded after trimming.\n   */\n  trimSTNs(lookbackDuration) {\n    let prunedNodes = 0;\n    const cutoffHighResTime = Math.max(now() - lookbackDuration, 0);\n    Object.keys(this.trace).forEach(nameCategory => {\n      const nodeList = this.trace[nameCategory];\n      /* Notice nodes are appending under their name's list as they end and are stored. This means each list is already (roughly) sorted in chronological order by end time.\n       * This isn't exact since nodes go through some processing & EE handlers chain, but it's close enough as we still capture nodes whose duration overlaps the lookback window.\n       * ASSUMPTION: all 'end' timings stored are relative to timeOrigin (DOMHighResTimeStamp) and not Unix epoch based. */\n      let cutoffIdx = nodeList.findIndex(node => cutoffHighResTime <= node.e);\n      if (cutoffIdx === 0) return;else if (cutoffIdx < 0) {\n        // whole list falls outside lookback window and is irrelevant\n        cutoffIdx = nodeList.length;\n        delete this.trace[nameCategory];\n      } else nodeList.splice(0, cutoffIdx); // chop off everything outside our window i.e. before the last <lookbackDuration> timeframe\n\n      this.nodeCount -= cutoffIdx;\n      prunedNodes += cutoffIdx;\n    });\n    return prunedNodes;\n  }\n\n  // Used by session trace's harvester to create the payload body.\n  takeSTNs(retry) {\n    if (!this.resourceObserver) {\n      // if PO isn't supported, this checks resourcetiming buffer every harvest.\n      this.storeResources(window.performance.getEntriesByType('resource'));\n    }\n    let earliestTimeStamp = Infinity;\n    const stns = Object.entries(this.trace).flatMap(_ref3 => {\n      let [name, listOfSTNodes] = _ref3;\n      // basically take the \"this.trace\" map-obj and concat all the list-type values\n      const oldestNodeTS = listOfSTNodes.reduce((acc, next) => !acc || next.s < acc ? next.s : acc, undefined);\n      if (oldestNodeTS < earliestTimeStamp) earliestTimeStamp = oldestNodeTS;\n      if (!(name in toAggregate)) return listOfSTNodes;\n      // Special processing for event nodes dealing with user inputs:\n      const reindexByOriginFn = this.smearEvtsByOrigin(name);\n      const partitionListByOriginMap = listOfSTNodes.sort((a, b) => a.s - b.s).reduce(reindexByOriginFn, {});\n      return Object.values(partitionListByOriginMap).flat(); // join the partitions back into 1-D, now ordered by origin then start time\n    }, this);\n    if (stns.length === 0) return {};\n    if (retry) {\n      this.sentTrace = this.trace;\n    }\n    this.trace = {};\n    this.nodeCount = 0;\n    let firstHarvestOfSession;\n    if (this.agentRuntime.session) {\n      const isFirstPayload = !this.agentRuntime.session.state.traceHarvestStarted;\n      firstHarvestOfSession = {\n        fsh: Number(isFirstPayload)\n      }; // converted to '0' | '1'\n      if (isFirstPayload) this.agentRuntime.session.write({\n        traceHarvestStarted: true\n      });\n    }\n    return {\n      qs: {\n        st: this.agentRuntime.offset,\n        /** hr === \"hasReplay\" in NR1, standalone is always checked and processed before harvesting\n         * so a race condition between ST and SR states should not be a concern if implemented here */\n        hr: Number(!this.isStandalone),\n        /** fts === \"firstTimestamp\" in NR1, indicates what the earliest NODE timestamp was\n         * so that blob parsing doesn't need to happen to support UI/API functions  */\n        fts: this.agentRuntime.offset + earliestTimeStamp,\n        /** n === \"nodeCount\" in NR1, a count of nodes in the ST payload, so that blob parsing doesn't need to happen to support UI/API functions */\n        n: stns.length,\n        // node count\n        ...firstHarvestOfSession\n      },\n      body: {\n        res: stns\n      }\n    };\n  }\n  smearEvtsByOrigin(name) {\n    const maxGap = toAggregate[name][0];\n    const maxLen = toAggregate[name][1];\n    const lastO = {};\n    return (byOrigin, evtNode) => {\n      let lastArr = byOrigin[evtNode.o];\n      if (!lastArr) lastArr = byOrigin[evtNode.o] = [];\n      const last = lastO[evtNode.o];\n      if (name === 'scrolling' && !trivial(evtNode)) {\n        lastO[evtNode.o] = null;\n        evtNode.n = 'scroll';\n        lastArr.push(evtNode);\n      } else if (last && evtNode.s - last.s < maxLen && last.e > evtNode.s - maxGap) {\n        last.e = evtNode.e;\n      } else {\n        lastO[evtNode.o] = evtNode;\n        lastArr.push(evtNode);\n      }\n      return byOrigin;\n    };\n    function trivial(node) {\n      const limit = 4;\n      return !!(node && typeof node.e === 'number' && typeof node.s === 'number' && node.e - node.s < limit);\n    }\n  }\n}","import unsupportedIterableToArray from \"./unsupportedIterableToArray.js\";\nexport default function _createForOfIteratorHelper(o, allowArrayLike) {\n  var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n  if (!it) {\n    if (Array.isArray(o) || (it = unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n      var F = function F() {};\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n  var normalCompletion = true,\n    didErr = false,\n    err;\n  return {\n    s: function s() {\n      it = it.call(o);\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it[\"return\"] != null) it[\"return\"]();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}"],"names":["onReplayReady","sessionReplayInitialized","Promise","resolve","sharedChannel","Object","freeze","HarvestScheduler","_SharedContext","_inherits","_super","_createSuper","endpoint","opts","parent","_this$sharedContext","_this","_classCallCheck","call","started","timeoutHandle","aborted","harvest","Harvest","sharedContext","subscribeToEOL","unload","bind","_assertThisInitialized","ee","on","SESSION_EVENTS","RESET","runHarvest","forceNoRetry","_createClass","key","value","this","onUnload","interval","initialDelay","scheduleHarvest","permanently","arguments","length","undefined","clearTimeout","delay","_this2","setTimeout","_this3","submitMethod","payload","cbRanAfterSend","result","retry","onHarvestFinished","harvests","getPayload","submitData","isFinalHarvest","prototype","toString","push","apply","_toConsumableArray","send","args","sendX","raw","_send","forEach","cbFinished","customUrl","onFinished","sent","retryDelay","SharedContext","isWorkerScope","globalScope","cleanupTasks","origClose","close","_step","_iterator","_createForOfIteratorHelper","s","n","done","task","err","e","f","cb","isBrowserScope","subscribeToVisibilityChange","windowAddEventListener","_classPrivateFieldSet","receiver","privateMap","descriptor","set","writable","TypeError","classExtractFieldDescriptor","HandlerCache","_classPrivateMethodInitSpec","_close","_drain","_classPrivateFieldInitSpec","_decision","_cache","_settleTimer","_classPrivateMethodGet","_close2","_noMoreChanges","handler","_classPrivateFieldGet","decision","_drain2","decide","h","getSessionReplayMode","_x","_getSessionReplayMode","_asyncToGenerator","_regeneratorRuntime","mark","_callee","agentId","newrelic","wrap","_context","prev","next","gosNREUM","getConfigurationValue","initializedAgents","features","session_replay","onAggregateImported","abrupt","t0","MODE","OFF","stop","ignoredEvents","global","mouseup","mousedown","window","load","pagehide","xhrOriginMissing","ignoreAll","toAggregate","typing","scrolling","mousing","touching","MAX_TRACE_DURATION","_scheduler","WeakMap","_onHarvestFinished","WeakSet","_prepareHarvest","_laststart","Aggregate","_AggregateBase","agentIdentifier","aggregator","argsObj","FEATURE_NAME","agentRuntime","getRuntime","xhrWrappable","_possibleConstructorReturn","resourceObserver","ptid","trace","nodeCount","sentTrace","harvestTimeSeconds","maxNodesPerHarvest","isStandalone","operationalGate","sessionEntity","session","controlTraceOp","traceMode","ERROR","startTracing","FULL","mostRecentModeKnown","seenAnError","registerHandler","state","sessionTraceMode","write","trimSTNs","needResponse","featureName","stopTracePerm","_classPrivateFieldGet2","_classPrivateFieldGet3","permanentlyDecide","stopTimer","waitForFlags","then","_ref4","_ref","_ref5","traceOn","replayMode","startingMode","_slicedToArray","RESUME","updatedTraceMode","PAUSE","isNew","sessionReplayMode","_len","Array","_key","settle","storeEvent","_len2","_key2","_this4","storeResources","_len3","_key3","_this5","storeHist","_len4","_key4","_this6","storeXhrAgg","_len5","_key5","_this7","storeSTN","_len6","_key6","_this8","storeErrorAgg","_len7","_key7","_this9","processPVT","drain","startupBuffer","dontStartHarvestYet","PerformanceNavigationTiming","storeTiming","performance","getEntriesByType","timing","_onHarvestFinished2","_prepareHarvest2","name","attrs","_defineProperty","fid","hasFID","type","target","timingEntry","val","lck","toLowerCase","indexOf","Math","round","o","t","currentEvent","start","end","shouldIgnoreEvent","evt","evtName","evtOrigin","event","origin","XMLHttpRequest","params","context","status","method","host","pathname","tagName","id","className","i","classList","document","FileReader","path","old","time","node","resources","_this10","currentResource","fetchStart","parsed","parseUrl","res","initiatorType","responseEnd","protocol","hostname","port","entryType","metrics","message","stackHash","duration","stn","now","lookbackDuration","_this11","prunedNodes","cutoffHighResTime","max","keys","nameCategory","nodeList","cutoffIdx","findIndex","splice","_this12","firstHarvestOfSession","earliestTimeStamp","Infinity","stns","entries","flatMap","_ref3","_ref6","listOfSTNodes","oldestNodeTS","reduce","acc","reindexByOriginFn","smearEvtsByOrigin","partitionListByOriginMap","sort","a","b","values","flat","isFirstPayload","traceHarvestStarted","fsh","Number","qs","_objectSpread","st","offset","hr","fts","body","maxGap","maxLen","lastO","byOrigin","evtNode","lastArr","last","limit","trivial","AggregateBase","_this13","responseText","startTimer","_ref2","_ref7","concat","options","currentMode","takeSTNs","allowArrayLike","it","Symbol","iterator","isArray","F","_e","normalCompletion","didErr","step","_e2"],"sourceRoot":""}