{"version":3,"file":"static/js/session_replay-aggregate.0ac95ef8.chunk.js","mappings":"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","sources":["../node_modules/@newrelic/browser-agent/dist/esm/common/constants/shared-channel.js","../node_modules/@newrelic/browser-agent/dist/esm/common/harvest/harvest-scheduler.js","../node_modules/@newrelic/browser-agent/dist/esm/common/unload/eol.js","../node_modules/@newrelic/browser-agent/dist/esm/features/session_replay/aggregate/index.js","../node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js"],"sourcesContent":["/**\n * @file Keeps an object alive that is passed to all feature aggregate modules.\n * The purpose is to have a way for communication and signals to relay across features at runtime.\n * This object can hold any arbitrary values and should be treated as on-the-fly dynamic.\n */\n\nlet onReplayReady;\nconst sessionReplayInitialized = new Promise(resolve => {\n  onReplayReady = resolve;\n});\nexport const sharedChannel = Object.freeze({\n  onReplayReady,\n  sessionReplayInitialized\n});","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport * as submitData from '../util/submit-data';\nimport { SharedContext } from '../context/shared-context';\nimport { Harvest } from './harvest';\nimport { subscribeToEOL } from '../unload/eol';\nimport { SESSION_EVENTS } from '../session/session-entity';\n\n/**\n * Periodically invokes harvest calls and handles retries\n */\nexport class HarvestScheduler extends SharedContext {\n  /**\n     * Create a HarvestScheduler\n     * @param {string} endpoint - The base BAM endpoint name -- ex. 'events'\n     * @param {object} opts - The options used to configure the HarvestScheduler\n     * @param {Function} opts.onFinished - The callback to be fired when a harvest has finished\n     * @param {Function} opts.getPayload - A callback which can be triggered to return a payload for harvesting\n     * @param {number} opts.retryDelay - The number of seconds to wait before retrying after a network failure\n     * @param {boolean} opts.raw - Use a prefabricated payload shape as the harvest payload without the need for formatting\n     * @param {string} opts.customUrl - A custom url that falls outside of the shape of the standard BAM harvester url pattern.  Will use directly instead of concatenating various pieces\n     * @param {*} parent - The parent object, whose state can be passed into SharedContext\n     */\n  constructor(endpoint, opts, parent) {\n    super(parent); // gets any allowed properties from the parent and stores them in `sharedContext`\n    this.endpoint = endpoint;\n    this.opts = opts || {};\n    this.started = false;\n    this.timeoutHandle = null;\n    this.aborted = false; // this controls the per-interval and final harvests for the scheduler (currently per feature specific!)\n\n    this.harvest = new Harvest(this.sharedContext);\n\n    // unload if EOL mechanism fires\n    subscribeToEOL(this.unload.bind(this));\n\n    /* Flush all buffered data if session resets and give up retries. This should be synchronous to ensure that the correct `session` value is sent.\n      Since session-reset generates a new session ID and the ID is grabbed at send-time, any delays or retries would cause the payload to be sent under\n      the wrong session ID. */\n    this.sharedContext?.ee.on(SESSION_EVENTS.RESET, () => this.runHarvest({\n      forceNoRetry: true\n    }));\n  }\n\n  /**\n   * This function is only meant for the last outgoing harvest cycle of a page. It trickles down to using sendBeacon, which should not be used\n   * to send payloads while the page is still active, due to limitations on how much data can be buffered in the API at any one time.\n   */\n  unload() {\n    if (this.aborted) return;\n    // If opts.onUnload is defined, these are special actions to execute before attempting to send the final payload.\n    if (this.opts.onUnload) this.opts.onUnload();\n    this.runHarvest({\n      unload: true\n    });\n  }\n  startTimer(interval, initialDelay) {\n    this.interval = interval;\n    this.started = true;\n    this.scheduleHarvest(initialDelay != null ? initialDelay : this.interval);\n  }\n  stopTimer() {\n    let permanently = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    this.aborted = permanently; // stopping permanently is same as aborting, but this function also cleans up the setTimeout loop\n    this.started = false;\n    if (this.timeoutHandle) {\n      clearTimeout(this.timeoutHandle);\n    }\n  }\n  scheduleHarvest(delay, opts) {\n    if (this.timeoutHandle) return;\n    if (delay == null) {\n      delay = this.interval;\n    }\n    this.timeoutHandle = setTimeout(() => {\n      this.timeoutHandle = null;\n      this.runHarvest(opts);\n    }, delay * 1000);\n  }\n  runHarvest(opts) {\n    if (this.aborted) return;\n\n    /**\n     * This is executed immediately after harvest sends the data via XHR, or if there's nothing to send. Note that this excludes on unloading / sendBeacon.\n     * @param {Object} result\n     */\n    const cbRanAfterSend = result => {\n      if (opts?.forceNoRetry) result.retry = false; // discard unsent data rather than re-queuing for next harvest attempt\n      this.onHarvestFinished(opts, result);\n    };\n    let harvests = [];\n    let submitMethod;\n    let payload;\n    if (this.opts.getPayload) {\n      // Ajax & PVT & SR features provide a callback function to get data for harvesting\n      submitMethod = submitData.getSubmitMethod({\n        isFinalHarvest: opts?.unload\n      });\n      if (!submitMethod) return false;\n      const retry = !opts?.unload && submitMethod === submitData.xhr;\n      payload = this.opts.getPayload({\n        retry\n      });\n      if (!payload) {\n        if (this.started) {\n          this.scheduleHarvest();\n        }\n        return;\n      }\n      payload = Object.prototype.toString.call(payload) === '[object Array]' ? payload : [payload];\n      harvests.push(...payload);\n    }\n\n    /** sendX is used for features that do not supply a preformatted payload via \"getPayload\" */\n    let send = args => this.harvest.sendX(args);\n    if (harvests.length) {\n      /** _send is the underlying method for sending in the harvest, if sending raw we can bypass the other helpers completely which format the payloads */\n      if (this.opts.raw) send = args => this.harvest._send(args);\n      /** send is used to formated the payloads from \"getPayload\" and obfuscate before sending */else send = args => this.harvest.send(args);\n    } else {\n      // force it to run at least once in sendX mode\n      harvests.push(undefined);\n    }\n    harvests.forEach(payload => {\n      send({\n        endpoint: this.endpoint,\n        payload,\n        opts,\n        submitMethod,\n        cbFinished: cbRanAfterSend,\n        customUrl: this.opts.customUrl,\n        raw: this.opts.raw\n      });\n    });\n    if (this.started) {\n      this.scheduleHarvest();\n    }\n  }\n  onHarvestFinished(opts, result) {\n    if (this.opts.onFinished) {\n      this.opts.onFinished(result);\n    }\n    if (result.sent && result.retry) {\n      const delay = result.delay || this.opts.retryDelay;\n      // reschedule next harvest if should be delayed longer\n      if (this.started && delay) {\n        clearTimeout(this.timeoutHandle);\n        this.timeoutHandle = null;\n        this.scheduleHarvest(delay, opts);\n      } else if (!this.started && delay) {\n        // if not running on a timer, schedule a single retry\n        this.scheduleHarvest(delay, opts);\n      }\n    }\n  }\n}","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { windowAddEventListener } from '../event-listener/event-listener-opts';\nimport { globalScope, isWorkerScope, isBrowserScope } from '../constants/runtime';\nimport { subscribeToVisibilityChange } from '../window/page-visibility';\nif (isWorkerScope) {\n  globalScope.cleanupTasks = []; // create new list on WorkerGlobalScope to track funcs to run before exiting thread\n\n  const origClose = globalScope.close;\n  globalScope.close = () => {\n    // on worker's EoL signal, execute all \"listeners\", e.g. final harvests\n    for (let task of globalScope.cleanupTasks) {\n      task();\n    }\n    origClose();\n  };\n}\n\n/**\n * Subscribes a provided callback to the time/event when the agent should treat it as end-of-life.\n * This is used, for example, to submit a final harvest and send all remaining data on best-effort.\n * @param {function} cb - func to run before or during the last reliable event or time of an env's life span\n */\nexport function subscribeToEOL(cb) {\n  if (isBrowserScope) {\n    subscribeToVisibilityChange(cb, true); // when user switches tab or hides window, esp. mobile scenario\n    windowAddEventListener('pagehide', cb); // when user navigates away, and because safari iOS v14.4- doesn't fully support vis change\n    // --this ought to be removed once support for version below 14.5 phases out\n  } else if (isWorkerScope) {\n    globalScope.cleanupTasks.push(cb); // close() should run these tasks before quitting thread\n  }\n  // By default (for other env), this fn has no effect.\n}","/*\n * Copyright 2023 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n/**\n * @file Records, aggregates, and harvests session replay data.\n *\n * NOTE: This code is under development and dormant. It will not download to instrumented pages or record any data.\n * It is not production ready, and is not intended to be imported or implemented in any build of the browser agent until\n * functionality is validated and a full user experience is curated.\n */\n\nimport { registerHandler } from '../../../common/event-emitter/register-handler';\nimport { HarvestScheduler } from '../../../common/harvest/harvest-scheduler';\nimport { FEATURE_NAME } from '../constants';\nimport { stringify } from '../../../common/util/stringify';\nimport { getConfigurationValue, getInfo, getRuntime } from '../../../common/config/config';\nimport { SESSION_EVENTS, MODE, SESSION_EVENT_TYPES } from '../../../common/session/session-entity';\nimport { AggregateBase } from '../../utils/aggregate-base';\nimport { sharedChannel } from '../../../common/constants/shared-channel';\nimport { obj as encodeObj } from '../../../common/url/encode';\nimport { warn } from '../../../common/util/console';\nimport { globalScope } from '../../../common/constants/runtime';\nimport { SUPPORTABILITY_METRIC_CHANNEL } from '../../metrics/constants';\nimport { handle } from '../../../common/event-emitter/handle';\nimport { FEATURE_NAMES } from '../../../loaders/features/features';\nimport { RRWEB_VERSION } from \"../../../common/constants/env.npm\";\nexport const AVG_COMPRESSION = 0.12;\nexport const RRWEB_EVENT_TYPES = {\n  DomContentLoaded: 0,\n  Load: 1,\n  FullSnapshot: 2,\n  IncrementalSnapshot: 3,\n  Meta: 4,\n  Custom: 5\n};\nconst ABORT_REASONS = {\n  RESET: {\n    message: 'Session was reset',\n    sm: 'Reset'\n  },\n  IMPORT: {\n    message: 'Recorder failed to import',\n    sm: 'Import'\n  },\n  TOO_MANY: {\n    message: '429: Too Many Requests',\n    sm: 'Too-Many'\n  },\n  TOO_BIG: {\n    message: 'Payload was too large',\n    sm: 'Too-Big'\n  },\n  CROSS_TAB: {\n    message: 'Session Entity was set to OFF on another tab',\n    sm: 'Cross-Tab'\n  }\n};\nlet recorder, gzipper, u8;\n\n/** Vortex caps payload sizes at 1MB */\nexport const MAX_PAYLOAD_SIZE = 1000000;\n/** Unloading caps around 64kb */\nexport const IDEAL_PAYLOAD_SIZE = 64000;\n/** Interval between forcing new full snapshots -- 15 seconds in error mode (x2), 5 minutes in full mode */\nconst CHECKOUT_MS = {\n  [MODE.ERROR]: 15000,\n  [MODE.FULL]: 300000,\n  [MODE.OFF]: 0\n};\nexport class Aggregate extends AggregateBase {\n  static featureName = FEATURE_NAME;\n  constructor(agentIdentifier, aggregator) {\n    super(agentIdentifier, aggregator, FEATURE_NAME);\n    /** Each page mutation or event will be stored (raw) in this array. This array will be cleared on each harvest */\n    this.events = [];\n    /** Backlog used for a 2-part sliding window to guarantee a 15-30s buffer window */\n    this.backloggedEvents = [];\n    /** The interval to harvest at.  This gets overridden if the size of the payload exceeds certain thresholds */\n    this.harvestTimeSeconds = getConfigurationValue(this.agentIdentifier, 'session_replay.harvestTimeSeconds') || 60;\n    /** Set once the recorder has fully initialized after flag checks and sampling */\n    this.initialized = false;\n    /** Set once an error has been detected on the page. Never unset */\n    this.errorNoticed = false;\n    /** The \"mode\" to record in.  Defaults to \"OFF\" until flags and sampling are checked. See \"MODE\" constant. */\n    this.mode = MODE.OFF;\n    /** Set once the feature has been \"aborted\" to prevent other side-effects from continuing */\n    this.blocked = false;\n    /** True when actively recording, false when paused or stopped */\n    this.recording = false;\n    /** can shut off efforts to compress the data */\n    this.shouldCompress = true;\n\n    /** Payload metadata -- Should indicate that the payload being sent has a full DOM snapshot. This can happen\n     * -- When the recording library begins recording, it starts by taking a DOM snapshot\n     * -- When visibility changes from \"hidden\" -> \"visible\", it must capture a full snapshot for the replay to work correctly across tabs\n    */\n    this.hasSnapshot = false;\n    /** Payload metadata -- Should indicate that the payload being sent has a meta node. The meta node should always precede a snapshot node. */\n    this.hasMeta = false;\n    /** Payload metadata -- Should indicate that the payload being sent contains an error.  Used for query/filter purposes in UI */\n    this.hasError = false;\n\n    /** Payload metadata -- Should indicate when a replay blob started recording.  Resets each time a harvest occurs.\n     * cycle timestamps are used as fallbacks if event timestamps cannot be used\n     */\n    this.cycleTimestamp = undefined;\n\n    /** A value which increments with every new mutation node reported. Resets after a harvest is sent */\n    this.payloadBytesEstimation = 0;\n\n    /** Hold on to the last meta node, so that it can be re-inserted if the meta and snapshot nodes are broken up due to harvesting */\n    this.lastMeta = undefined;\n    const shouldSetup = getConfigurationValue(agentIdentifier, 'privacy.cookies_enabled') === true && getConfigurationValue(agentIdentifier, 'session_trace.enabled') === true;\n\n    /** The method to stop recording. This defaults to a noop, but is overwritten once the recording library is imported and initialized */\n    this.stopRecording = () => {/* no-op until set by rrweb initializer */};\n    if (shouldSetup) {\n      // The SessionEntity class can emit a message indicating the session was cleared and reset (expiry, inactivity). This feature must abort and never resume if that occurs.\n      this.ee.on(SESSION_EVENTS.RESET, () => {\n        this.abort(ABORT_REASONS.RESET);\n      });\n\n      // The SessionEntity class can emit a message indicating the session was paused (visibility change). This feature must stop recording if that occurs.\n      this.ee.on(SESSION_EVENTS.PAUSE, () => {\n        this.stopRecording();\n      });\n      // The SessionEntity class can emit a message indicating the session was resumed (visibility change). This feature must start running again (if already running) if that occurs.\n      this.ee.on(SESSION_EVENTS.RESUME, () => {\n        // if the mode changed on a different tab, it needs to update this instance to match\n        const {\n          session\n        } = getRuntime(this.agentIdentifier);\n        this.mode = session.state.sessionReplayMode;\n        if (!this.initialized || this.mode === MODE.OFF) return;\n        this.startRecording();\n      });\n      this.ee.on(SESSION_EVENTS.UPDATE, (type, data) => {\n        if (!this.initialized || this.blocked || type !== SESSION_EVENT_TYPES.CROSS_TAB) return;\n        if (this.mode !== MODE.OFF && data.sessionReplayMode === MODE.OFF) this.abort(ABORT_REASONS.CROSS_TAB);\n        this.mode = data.sessionReplay;\n      });\n\n      // Bespoke logic for new endpoint.  This will change as downstream dependencies become solidified.\n      this.scheduler = new HarvestScheduler('browser/blobs', {\n        onFinished: this.onHarvestFinished.bind(this),\n        retryDelay: this.harvestTimeSeconds,\n        getPayload: this.prepareHarvest.bind(this),\n        raw: true\n      }, this);\n\n      // Wait for an error to be reported.  This currently is wrapped around the \"Error\" feature.  This is a feature-feature dependency.\n      // This was to ensure that all errors, including those on the page before load and those handled with \"noticeError\" are accounted for. Needs evalulation\n      registerHandler('errorAgg', e => {\n        this.hasError = true;\n        this.errorNoticed = true;\n        // run once\n        if (this.mode === MODE.ERROR && globalScope?.document.visibilityState === 'visible') {\n          this.mode = MODE.FULL;\n          // if the error was noticed AFTER the recorder was already imported....\n          if (recorder && this.initialized) {\n            this.stopRecording();\n            this.startRecording();\n            this.scheduler.startTimer(this.harvestTimeSeconds);\n            this.syncWithSessionManager({\n              sessionReplayMode: this.mode\n            });\n          }\n        }\n      }, this.featureName, this.ee);\n      this.waitForFlags(['sr']).then(_ref => {\n        let [flagOn] = _ref;\n        return this.initializeRecording(flagOn, Math.random() * 100 < getConfigurationValue(this.agentIdentifier, 'session_replay.error_sampling_rate'), Math.random() * 100 < getConfigurationValue(this.agentIdentifier, 'session_replay.sampling_rate'));\n      }).then(() => sharedChannel.onReplayReady(this.mode)); // notify watchers that replay started with the mode\n\n      this.drain();\n    }\n  }\n\n  /**\n   * Evaluate entitlements and sampling before starting feature mechanics, importing and configuring recording library, and setting storage state\n   * @param {boolean} entitlements - the true/false state of the \"sr\" flag from RUM response\n   * @param {boolean} errorSample - the true/false state of the error sampling decision\n   * @param {boolean} fullSample - the true/false state of the full sampling decision\n   * @returns {void}\n   */\n  async initializeRecording(entitlements, errorSample, fullSample) {\n    this.initialized = true;\n    if (!entitlements) return;\n    const {\n      session\n    } = getRuntime(this.agentIdentifier);\n    // if theres an existing session replay in progress, there's no need to sample, just check the entitlements response\n    // if not, these sample flags need to be checked\n    // if this isnt the FIRST load of a session AND\n    // we are not actively recording SR... DO NOT import or run the recording library\n    // session replay samples can only be decided on the first load of a session\n    // session replays can continue if already in progress\n    if (!session.isNew) {\n      // inherit the mode of the existing session\n      this.mode = session.state.sessionReplayMode;\n    } else {\n      // The session is new... determine the mode the new session should start in\n      if (fullSample) this.mode = MODE.FULL; // full mode has precedence over error mode\n      else if (errorSample) this.mode = MODE.ERROR;\n      // If neither are selected, then don't record (early return)\n      else return;\n    }\n\n    // If an error was noticed before the mode could be set (like in the early lifecycle of the page), immediately set to FULL mode\n    if (this.mode === MODE.ERROR && this.errorNoticed) {\n      this.mode = MODE.FULL;\n    }\n    try {\n      // Do not change the webpackChunkName or it will break the webpack nrba-chunking plugin\n      recorder = (await import( /* webpackChunkName: \"recorder\" */'rrweb')).record;\n    } catch (err) {\n      return this.abort(ABORT_REASONS.IMPORT);\n    }\n\n    // FULL mode records AND reports from the beginning, while ERROR mode only records (but does not report).\n    // ERROR mode will do this until an error is thrown, and then switch into FULL mode.\n    // If an error happened in ERROR mode before we've gotten to this stage, it will have already set the mode to FULL\n    if (this.mode === MODE.FULL) {\n      // We only report (harvest) in FULL mode\n      this.scheduler.startTimer(this.harvestTimeSeconds);\n    }\n    try {\n      // Do not change the webpackChunkName or it will break the webpack nrba-chunking plugin\n      const {\n        gzipSync,\n        strToU8\n      } = await import( /* webpackChunkName: \"compressor\" */'fflate');\n      gzipper = gzipSync;\n      u8 = strToU8;\n    } catch (err) {\n      // compressor failed to load, but we can still record without compression as a last ditch effort\n      this.shouldCompress = false;\n    }\n    this.startRecording();\n    this.syncWithSessionManager({\n      sessionReplayMode: this.mode\n    });\n  }\n  prepareHarvest() {\n    if (this.events.length === 0 || this.mode !== MODE.FULL && !this.blocked) return;\n    const payload = this.getHarvestContents();\n    if (!payload.body.length) {\n      this.clearBuffer();\n      return;\n    }\n    if (this.shouldCompress) {\n      payload.body = gzipper(u8(stringify(payload.body)));\n      this.scheduler.opts.gzip = true;\n    } else {\n      this.scheduler.opts.gzip = false;\n    }\n    // TODO -- Gracefully handle the buffer for retries.\n    const {\n      session\n    } = getRuntime(this.agentIdentifier);\n    if (!session.state.sessionReplaySentFirstChunk) this.syncWithSessionManager({\n      sessionReplaySentFirstChunk: true\n    });\n    this.clearBuffer();\n    return [payload];\n  }\n  getHarvestContents() {\n    const agentRuntime = getRuntime(this.agentIdentifier);\n    const info = getInfo(this.agentIdentifier);\n    if (this.backloggedEvents.length) this.events = [...this.backloggedEvents, ...this.events];\n\n    // do not let the first node be a full snapshot node, since this NEEDS to be preceded by a meta node\n    // we will manually inject it if this happens\n    const payloadStartsWithFullSnapshot = this.events[0]?.type === RRWEB_EVENT_TYPES.FullSnapshot;\n    if (payloadStartsWithFullSnapshot && !!this.lastMeta) {\n      this.hasMeta = true;\n      this.events.unshift(this.lastMeta); // --> pushed the meta from a previous payload into newer payload... but it still has old timestamps\n      this.lastMeta = undefined;\n    }\n\n    // do not let the last node be a meta node, since this NEEDS to precede a snapshot\n    // we will manually inject it later if we find a payload that is missing a meta node\n    const payloadEndsWithMeta = this.events[this.events.length - 1]?.type === RRWEB_EVENT_TYPES.Meta;\n    if (payloadEndsWithMeta) {\n      this.lastMeta = this.events[this.events.length - 1];\n      this.events = this.events.slice(0, this.events.length - 1);\n      this.hasMeta = !!this.events.find(x => x.type === RRWEB_EVENT_TYPES.Meta);\n    }\n    const firstEventTimestamp = this.events[0]?.timestamp; // from rrweb node\n    const lastEventTimestamp = this.events[this.events.length - 1]?.timestamp; // from rrweb node\n    const firstTimestamp = firstEventTimestamp || this.cycleTimestamp;\n    const lastTimestamp = lastEventTimestamp || getRuntime(this.agentIdentifier).offset + globalScope.performance.now();\n    return {\n      qs: {\n        browser_monitoring_key: info.licenseKey,\n        type: 'SessionReplay',\n        app_id: info.applicationID,\n        protocol_version: '0',\n        attributes: encodeObj({\n          ...(this.shouldCompress && {\n            content_encoding: 'gzip'\n          }),\n          'replay.firstTimestamp': firstTimestamp,\n          'replay.lastTimestamp': lastTimestamp,\n          'replay.durationMs': lastTimestamp - firstTimestamp,\n          'replay.nodes': this.events.length,\n          agentVersion: agentRuntime.version,\n          session: agentRuntime.session.state.value,\n          hasMeta: this.hasMeta,\n          hasSnapshot: this.hasSnapshot,\n          hasError: this.hasError,\n          isFirstChunk: agentRuntime.session.state.sessionReplaySentFirstChunk === false,\n          decompressedBytes: this.payloadBytesEstimation,\n          'nr.rrweb.version': RRWEB_VERSION\n        }, MAX_PAYLOAD_SIZE - this.payloadBytesEstimation).substring(1) // remove the leading '&'\n      },\n\n      body: this.events\n    };\n  }\n  onHarvestFinished(result) {\n    // The mutual decision for now is to stop recording and clear buffers if ingest is experiencing 429 rate limiting\n    if (result.status === 429) {\n      this.abort(ABORT_REASONS.TOO_MANY);\n    }\n    if (this.blocked) this.scheduler.stopTimer(true);\n  }\n\n  /** Clears the buffer (this.events), and resets all payload metadata properties */\n  clearBuffer() {\n    if (this.mode === MODE.ERROR) this.backloggedEvents = this.events;else this.backloggedEvents = [];\n    this.events = [];\n    this.hasSnapshot = false;\n    this.hasMeta = false;\n    this.hasError = false;\n    this.payloadBytesEstimation = 0;\n    this.clearTimestamps();\n  }\n\n  /** Begin recording using configured recording lib */\n  startRecording() {\n    if (!recorder) {\n      warn('Recording library was never imported');\n      return this.abort(ABORT_REASONS.IMPORT);\n    }\n    this.recording = true;\n    const {\n      block_class,\n      ignore_class,\n      mask_text_class,\n      block_selector,\n      mask_input_options,\n      mask_text_selector,\n      mask_all_inputs,\n      inline_images,\n      inline_stylesheet,\n      collect_fonts\n    } = getConfigurationValue(this.agentIdentifier, 'session_replay');\n    // set up rrweb configurations for maximum privacy --\n    // https://newrelic.atlassian.net/wiki/spaces/O11Y/pages/2792293280/2023+02+28+Browser+-+Session+Replay#Configuration-options\n    const stop = recorder({\n      emit: this.store.bind(this),\n      blockClass: block_class,\n      ignoreClass: ignore_class,\n      maskTextClass: mask_text_class,\n      blockSelector: block_selector,\n      maskInputOptions: mask_input_options,\n      maskTextSelector: mask_text_selector,\n      maskAllInputs: mask_all_inputs,\n      inlineImages: inline_images,\n      inlineStylesheet: inline_stylesheet,\n      collectFonts: collect_fonts,\n      checkoutEveryNms: CHECKOUT_MS[this.mode]\n    });\n    this.stopRecording = () => {\n      this.recording = false;\n      stop();\n    };\n  }\n\n  /** Store a payload in the buffer (this.events).  This should be the callback to the recording lib noticing a mutation */\n  store(event, isCheckout) {\n    this.setTimestamps();\n    if (this.blocked) return;\n    const eventBytes = stringify(event).length;\n    /** The estimated size of the payload after compression */\n    const payloadSize = this.getPayloadSize(eventBytes);\n    // Vortex will block payloads at a certain size, we might as well not send.\n    if (payloadSize > MAX_PAYLOAD_SIZE) {\n      this.clearBuffer();\n      return this.abort(ABORT_REASONS.TOO_BIG);\n    }\n    // Checkout events are flags by the recording lib that indicate a fullsnapshot was taken every n ms. These are important\n    // to help reconstruct the replay later and must be included.  While waiting and buffering for errors to come through,\n    // each time we see a new checkout, we can drop the old data.\n    // we need to check for meta because rrweb will flag it as checkout twice, once for meta, then once for snapshot\n    if (this.mode === MODE.ERROR && isCheckout && event.type === RRWEB_EVENT_TYPES.Meta) {\n      // we are still waiting for an error to throw, so keep wiping the buffer over time\n      this.clearBuffer();\n    }\n\n    // meta event\n    if (event.type === RRWEB_EVENT_TYPES.Meta) {\n      this.hasMeta = true;\n    }\n    // snapshot event\n    if (event.type === RRWEB_EVENT_TYPES.FullSnapshot) {\n      this.hasSnapshot = true;\n    }\n    this.events.push(event);\n    this.payloadBytesEstimation += eventBytes;\n\n    // We are making an effort to try to keep payloads manageable for unloading.  If they reach the unload limit before their interval,\n    // it will send immediately.  This often happens on the first snapshot, which can be significantly larger than the other payloads.\n    if (payloadSize > IDEAL_PAYLOAD_SIZE && this.mode !== MODE.ERROR) {\n      // if we've made it to the ideal size of ~64kb before the interval timer, we should send early.\n      this.scheduler.runHarvest();\n    }\n  }\n\n  /** force the recording lib to take a full DOM snapshot.  This needs to occur in certain cases, like visibility changes */\n  takeFullSnapshot() {\n    if (!recorder) return;\n    recorder.takeFullSnapshot();\n  }\n  setTimestamps() {\n    // fallbacks if timestamps cannot be derived from rrweb events\n    if (!this.cycleTimestamp) this.cycleTimestamp = getRuntime(this.agentIdentifier).offset + globalScope.performance.now();\n  }\n  clearTimestamps() {\n    this.cycleTimestamp = undefined;\n  }\n\n  /** Estimate the payload size */\n  getPayloadSize() {\n    let newBytes = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    // the 1KB gives us some padding for the other metadata\n    return this.estimateCompression(this.payloadBytesEstimation + newBytes) + 1000;\n  }\n\n  /** Abort the feature, once aborted it will not resume */\n  abort() {\n    let reason = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    warn(\"SR aborted -- \".concat(reason.message));\n    handle(SUPPORTABILITY_METRIC_CHANNEL, [\"SessionReplay/Abort/\".concat(reason.sm)], undefined, FEATURE_NAMES.metrics, this.ee);\n    this.blocked = true;\n    this.mode = MODE.OFF;\n    this.stopRecording();\n    this.syncWithSessionManager({\n      sessionReplayMode: this.mode\n    });\n    this.clearTimestamps();\n    this.ee.emit('REPLAY_ABORTED');\n  }\n\n  /** Extensive research has yielded about an 88% compression factor on these payloads.\n   * This is an estimation using that factor as to not cause performance issues while evaluating\n   * https://staging.onenr.io/037jbJWxbjy\n   * */\n  estimateCompression(data) {\n    if (this.shouldCompress) return data * AVG_COMPRESSION;\n    return data;\n  }\n  syncWithSessionManager() {\n    let state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const {\n      session\n    } = getRuntime(this.agentIdentifier);\n    session.write(state);\n  }\n}","import unsupportedIterableToArray from \"./unsupportedIterableToArray.js\";\nexport default function _createForOfIteratorHelper(o, allowArrayLike) {\n  var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n  if (!it) {\n    if (Array.isArray(o) || (it = unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n      var F = function F() {};\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n  var normalCompletion = true,\n    didErr = false,\n    err;\n  return {\n    s: function s() {\n      it = it.call(o);\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it[\"return\"] != null) it[\"return\"]();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}"],"names":["onReplayReady","sessionReplayInitialized","Promise","resolve","sharedChannel","Object","freeze","HarvestScheduler","_SharedContext","_inherits","_super","_createSuper","endpoint","opts","parent","_this$sharedContext","_this","_classCallCheck","call","started","timeoutHandle","aborted","harvest","Harvest","sharedContext","subscribeToEOL","unload","bind","_assertThisInitialized","ee","on","SESSION_EVENTS","RESET","runHarvest","forceNoRetry","_createClass","key","value","this","onUnload","interval","initialDelay","scheduleHarvest","permanently","arguments","length","undefined","clearTimeout","delay","_this2","setTimeout","_this3","submitMethod","payload","cbRanAfterSend","result","retry","onHarvestFinished","harvests","getPayload","submitData","isFinalHarvest","prototype","toString","push","apply","_toConsumableArray","send","args","sendX","raw","_send","forEach","cbFinished","customUrl","onFinished","sent","retryDelay","SharedContext","isWorkerScope","globalScope","cleanupTasks","origClose","close","_step","_iterator","_createForOfIteratorHelper","s","n","done","task","err","e","f","cb","isBrowserScope","subscribeToVisibilityChange","windowAddEventListener","recorder","gzipper","u8","AVG_COMPRESSION","RRWEB_EVENT_TYPES","DomContentLoaded","Load","FullSnapshot","IncrementalSnapshot","Meta","Custom","ABORT_REASONS","message","sm","MAX_PAYLOAD_SIZE","IDEAL_PAYLOAD_SIZE","CHECKOUT_MS","_CHECKOUT_MS","_defineProperty","MODE","ERROR","FULL","OFF","Aggregate","_AggregateBase","agentIdentifier","aggregator","FEATURE_NAME","events","backloggedEvents","harvestTimeSeconds","getConfigurationValue","initialized","errorNoticed","mode","blocked","recording","shouldCompress","hasSnapshot","hasMeta","hasError","cycleTimestamp","payloadBytesEstimation","lastMeta","shouldSetup","stopRecording","abort","PAUSE","RESUME","session","getRuntime","state","sessionReplayMode","startRecording","UPDATE","type","data","SESSION_EVENT_TYPES","CROSS_TAB","sessionReplay","scheduler","prepareHarvest","registerHandler","document","visibilityState","startTimer","syncWithSessionManager","featureName","waitForFlags","then","_ref","flagOn","_slicedToArray","initializeRecording","Math","random","drain","_initializeRecording","_asyncToGenerator","_regeneratorRuntime","mark","_callee","entitlements","errorSample","fullSample","_getRuntime2","_yield$import","gzipSync","strToU8","wrap","_context","prev","next","abrupt","isNew","record","t0","t1","stop","_x","_x2","_x3","getHarvestContents","body","stringify","gzip","sessionReplaySentFirstChunk","clearBuffer","_this$events$","_this$events","_this$events$2","_this$events2","agentRuntime","info","getInfo","concat","unshift","slice","find","x","firstEventTimestamp","timestamp","lastEventTimestamp","firstTimestamp","lastTimestamp","offset","performance","now","qs","browser_monitoring_key","licenseKey","app_id","applicationID","protocol_version","attributes","encodeObj","_objectSpread","content_encoding","agentVersion","version","isFirstChunk","decompressedBytes","RRWEB_VERSION","substring","status","stopTimer","clearTimestamps","warn","_getConfigurationValu","block_class","ignore_class","mask_text_class","block_selector","mask_input_options","mask_text_selector","mask_all_inputs","inline_images","inline_stylesheet","collect_fonts","emit","store","blockClass","ignoreClass","maskTextClass","blockSelector","maskInputOptions","maskTextSelector","maskAllInputs","inlineImages","inlineStylesheet","collectFonts","checkoutEveryNms","event","isCheckout","setTimestamps","eventBytes","payloadSize","getPayloadSize","takeFullSnapshot","newBytes","estimateCompression","reason","handle","SUPPORTABILITY_METRIC_CHANNEL","FEATURE_NAMES","metrics","write","AggregateBase","o","allowArrayLike","it","Symbol","iterator","Array","isArray","i","F","_e","TypeError","normalCompletion","didErr","step","_e2"],"sourceRoot":""}